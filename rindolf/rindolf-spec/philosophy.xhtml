<?xml version="1.0" encoding="UTF-8"?><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>Philosophy</title><link rel="stylesheet" type="text/css" href="docbook.css"/><link rel="stylesheet" type="text/css" href="style.css"/><meta name="generator" content="DocBook XSL Shlomif"/><link rel="prev" href="author.xhtml" title="Author"/><link rel="next" href="oop_features.xhtml" title="Object Oriented Programming Features"/></head><body><header><div class="center ads_top"/><div class="navheader"><table style="width:100%"><tr><th style="text-align:center" colspan="3">Philosophy</th></tr><tr><td style="width:20%;text-align:left"><a accesskey="p" href="author.xhtml">Prev</a> </td><th style="width:60%;text-align:center"> </th><td style="width:20%;text-align:right"> <a accesskey="n" href="oop_features.xhtml">Next</a></td></tr></table><hr/></div></header><section class="section"><div class="titlepage"><div><div><h2 id="philosophy" class="title">Philosophy</h2></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="philosophy.xhtml#philosophy_assumptions">The Assumptions behind Rindolf</a></span></li><li><span class="section"><a href="philosophy.xhtml#philosophy_explanation">Explanation</a></span></li><li><span class="section"><a href="philosophy.xhtml#philosophy_perl4">Analogy with the Perl 4/Perl 5 Conversion</a></span></li><li><span class="section"><a href="philosophy.xhtml#philosophy_cpp">Analogy with C++ and C</a></span></li><li><span class="section"><a href="philosophy.xhtml#philosophy_competition">How to handle the Competition?</a></span></li></ul></div><p>The purpose of this section is to explain the motivation behind Rindolf, what it is meant to accomplish, and what not. This section should be consulted before one wishes to add new functionality to Rindolf, in order to see if it corresponds with the philosophy.</p><section class="section"><div class="titlepage"><div><div><h3 id="philosophy_assumptions" class="title">The Assumptions behind Rindolf</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Perl is a <span class="emphasis"><em>family</em></span> of programming languages.</p></li><li class="listitem"><p>Perl 5 is a good language.</p></li><li class="listitem"><p>Perl 5 is not good enough for some purposes.</p></li><li class="listitem"><p>Perl 6, by not being backward compatible, does not provide a real answer to the Perl 5 deficiencies.</p></li><li class="listitem"><p>Rindolf aims to be an improved dialect of Perl compatible to Perl 5.</p></li></ol></div></section><section class="section"><div class="titlepage"><div><div><h3 id="philosophy_explanation" class="title">Explanation</h3></div></div></div><p>OK, here's the deal: if Perl 6 would have better designed, less bloated with superfluous features, and backward-compatible with Perl 5, I would not have started Rindolf. In fact, I consider Rindolf an anti-thesis to Perl 6. Thus, don't wonder if I criticize Perl 6 a lot, because it is the reason for starting Rindolf in the first place.</p><p>Perl 5 is a good language. Yet, it is facing a problem: competition. Perl faces competition from Python, PHP and to lesser extent Ruby, Tcl and other less dominant languages vowing for the so-called "scripting languages category". There's nothing wrong with this competition, and if someone is content programming in another language, there's no reason to tell him to use Perl instead. Still, it would not be good if Perl 5 lost ground due to the fact that it lacked features, which other languages possessed in a straightforward manner.</p><p>Now, Perl 6 is the wrong solution for the problem. As Perl 5 served as a handy scripting, glue and integration language in the past years, which saw an explosion of the Internet, of Linux, and of computing in general, there are now millions of lines of Perl 5 code written by hundreds of thousands of programmers. (perhaps even milliards LOCs written by millions of programmers - it's hard for me to approximate). These pieces of code do their job, work very nicely and are sometimes tweaked and modified as time goes by.</p><p>What is present in CPAN is just the tip of the iceberg. We can expect many modules in CPAN to have ad-hoc code that does the same job in many other places around the world. (I know I wrote a lot of code, that I later found out that there is a CPAN module that does exactly that). Furthermore, and equally importantly we can expect that there are now millions of Perl 5 programmers of varying skill and knowledge who constantly maintain such code or write new one for their own purposes.</p><p>Now, here comes a rhetorical question: exactly how are all of them going to convert to Perl 6, which is incredibly different and not compatible with Perl 5?</p><p id="cross_river_twice">The answer is they are not going to. They are going to stick to Perl 5. Converters, you say? They are not going to work for several reasons. First of all, the programmers themselves are used to Perl 5. As we all know, everyone has his own Perl 5 style which is different than others. <a href="#ftn.cross_river_twice" class="footnote"><sup class="footnote">[1]</sup></a> Teaching them all Perl 6 is a recipe for failure. Secondly, a converter will probably convert your code to something crude and hard to manage. (if it will convert it correctly at all - eval "" anyone?). Lastly, people will be very reluctant to use the converter, if the code is already working in Perl 5. "It's working - don't touch". Perl 5 is probably going to be around for a while, so why bother converting a perfectly good code to the incompatible, new-fangled Perl 6?</p><p>And that's where Rindolf kicks in. Rindolf is a Perl dialect that is fully backwards compatible with Perl 5, yet offers some features not present there. Running "rindolf test.pl" will 99% of the time yield the same results as running "perl test.pl". A person can take a code written for perl5, use it as is with Rindolf, and gradually add Rindolf-specific features should he wish to.</p><p>Rindolf maintains backwards-compatibility because Perl 5 is good enough as a basis for a language. More importantly, it is a language that is in wide use today, and people depend on.</p></section><section class="section"><div class="titlepage"><div><div><h3 id="philosophy_perl4" class="title">Analogy with the Perl 4/Perl 5 Conversion</h3></div></div></div><p>A few years ago, Larry Wall decided to dump Perl 4 for good and to create Perl 5, which was not backward compatible. Right now, the lack of backwards compatibility in Perl 6 is rationalized on similar notes. The situation, however, is completely different.</p><p>Perl 4 was a system and scripting language that still originated from the same Perl 1 codebase. It did not have half the features that Perl 5 has, and it was very hard to write maintainable code in it. I've seen Perl 4-like code written in Perl 5, and it was not a pretty sight. (I ended up Perl5-ing it). Perl 4 was an ad-hoc language used by a (relatively to nowadays small) number of UNIX sys-admins and users and was not much more than an awk with an attitude.</p><p>Furthermore, Perl 4 code could have been converted with some effort to Perl 5. Perl 5, in fact, still includes some operators only for backwards compatibility to Perl 4.</p><p>The situation today is very different. Perl 5 is widely deployed and used by many more users around the world. It is not only used for system scripts, but for automating web processes (in thousands of sites used by millions of online users), for complex text processing, database access, GUI programming (take the Mandrake system utilities and installer for example), games (Frozen-Bubble is a notable example), numerical processing (PerlDL) and almost everything else under the Sun that does not require very fast low-level processing.</p><p>Furthermore, it is very usable and supports most of the modern programming paradigms very well: Object-Oriented Programming, Functional Programming, Exceptions, text-processing, garbage collection, nested data structures, arbitrarily-sized data, etc. I'm not saying it's a perfect language, but inventing something entirely different, just to solve its deficiencies is sure to make many users (if not most) unhappy.</p><p>Now is the point for incremental renovation. Don't throw everything away. Start with what you have and build on there, without breaking everything. That's exactly what Rindolf aims to be.</p></section><section class="section"><div class="titlepage"><div><div><h3 id="philosophy_cpp" class="title">Analogy with C++ and C</h3></div></div></div><p>The analogy between Rindolf and Perl 5 and C++ and C is naturally something that needs to be addressed. C++ has seen wide use in the industry, while has almost been completely rejected by the open-source community who sticked to the bare ISO C 89'. Even some software houses maintain C codebases of various sizes, which they do not indeed to convert to C++. Is Rindolf going to have the same fate?</p><p>The answer is that it makes no different this way or another. I don't mind people sticking to the bare Perl 5 subset because Perl 5 is fine as it is. In fact, considering the Parrot architecture, I may write the Rindolf compiler in Perl 5 and keep it in Perl 5. (assuming rindolf will be based on Parrot). I believe that C++ could have had much more success, if it supported a saner subset of functionality, and did not push the standard beyond the limits of functionality, that takes compilers a lot of time to support properly.</p><p>Single-inheritance is useful (it is nicer than the Gtk+-style implementation in software), as are templates, ,operator overloading and friend functions. But at the moment, Standard C++ has become a completely different language than C, which is still backwards compatible. Mozilla, for instance, restricts itself to only a very small subset of the functionality to maintain compatibility with different broken compilers. (I also know someone who used friend classes or functions in his code, which worked well in gcc, and later broken in a different Solaris proprietary compiler)</p><p id="mikmod_for_java">Rindolf will still essentially be Perl 5-like with a Perl 5 feel and behaviour. Moreover, C++ has proved of some use to many projects, and is still commonly used. As much as there is a hype about Java and .NET, they are not compatible with C, and so aren't actually a replacement for C++. <a href="#ftn.mikmod_for_java" class="footnote"><sup class="footnote">[2]</sup></a> If Perl 5 is C, then Perl 6 is going to be something like Java. Rindolf will be C++, and the analogy is perfectly fine.</p></section><section class="section"><div class="titlepage"><div><div><h3 id="philosophy_competition" class="title">How to handle the Competition?</h3></div></div></div><p>When one is facing a competition, one has to admit it, to understand it is a good thing, but also to try not to lose ground. Many times two competitors each gain new users. Many times users are gained by one on the expense of the other. At the moment, Perl faces competition from Python, Ruby, Tcl, OCaml and some other minor players. Our most serious competitor is Python.</p><p>Now if you ask a common programmer who knows Perl and Python well enough what he thinks of both languages there are several possible answers. One is "I <span class="emphasis"><em>love</em></span> perl and despise everything that is Python." (I fall into this camp) One is "Python rocks, while Perl is a hideous, ugly inconsistent language". (I know some people who think that way). And another common one is "Perl is OK. Python is OK. Perl is good for some things, python for others. I like them both". A less common one is "They are both stupid. C++/ Java/LISP is the ultimate language!".</p><p>Now it's hard to tell which person will tell you which. It depends on the character of the Person, what he was used to before, and many other factors. My mother language was BASIC, and so I found Perl highly attractive. Later on when I learned other paradigms (The SICP stuff, Lambda Calculus, Object Oriented Programming, FP, nested data structures, etc.) I could easily find them in Perl 5. But then there may be other BASIC hackers who would prefer Python or Ruby.</p><p>There are dog people who prefer Perl, and there are dog people who prefer Python. There are cat people who prefer Perl (like me), and there are cat people who prefer Python. Now, one can notice that the fact that Perl resembles a natural language, and it is possible to write with it in various styles (even mixing several styles in one program) make it highly attractive to people who like think about <span class="emphasis"><em>how they are going to write the code</em></span>, and translate it naturally into code. People who like a strict syntax and conventions, an "everything is an object" concept, lack of "inelegant" features, and the "There's One Way to Do it" dogma prefer Python. Some people accept both opposing camps and like both languages</p><p>Many of the members of the Python camp are loud, keep professing the supposed advantages of its language, how maintainable the code can become, and how everyone is capable of understanding it. While Python has many features Perl does not yet have, it also does not have many others (here documents, labelled loops with breaking and continuing, a continue block, the use strict pragma and so forth). It also overloads every operator to many things: + can be used for both adding numbers, concatenating strings and concatenating arrays, three uses that are three different operators in Perl. The Perl people on the other hand take the "if you like programming in Python/C/C++/Java/Ruby/whatever, then hack on and stay cool".</p><p>I have already met two relative very young newbies whom I told that they should start with learning Perl, and they said "Perl? Why not Python?" Apparently, some people are under the impression that Perl is an inferior language to Python. It's very easy to get it. Eric Raymond recommends in the <a class="link" href="http://catb.org/~esr/faqs/hacker-howto.html">How to become a Hacker</a> HOWTO to start with learning Python and then learn C/C++, Perl, LISP, Shell and Java. (and afterwards become familiar with other languages that are of lesser significance to the world). I would recommend someone to start with Perl instead, but this is a difference of opinions between me and Raymond, which is not productive to delve on. (He took the time to write the HOWTO and so he gets to endorse his own favourite)</p><p>My point in making Rindolf is to make sure it has most of the important features Python (and similar languages like Ruby, Tcl or Haskell) has and Perl does not. I'd hate to lose ground because someone tried to do something in Perl and did not. However, as opposed to Perl 5, I'm not going to be concerned with Java (enough to make the arrow operator a "."), C++ (which supports Object Oriented Programming roughly as much as COBOL supports Functional Programming), C#, Visual Basic, Smalltalk or any language that is nowhere near Perl and does not compete for the same niche.</p><p>The Perl niche is high-level languages optimized for writing a lot of code quickly, commonly referred to as "scripting languages". These are the languages that most people like for their day to day hacking, that can be used as substitute for shell scripts (like I did when I first worked as a web-technician on UNIX), and can be used for GUI programming, numerical programming (with some extensions), simple games, text processing (naturally), web scripting, automating system tasks, and almost anything where you can afford to spend some overhead and don't need every single CPU cycle. Perl 6 from my impression aims to feel the niche for every possible use under the sun. But we cannot invent a language that will be good for anything, just as we cannot invent such a screw-driver.</p></section><div class="footnotes"><br/><hr class="footnote-hr"/><div id="ftn.cross_river_twice" class="footnote"><p><a href="#cross_river_twice" class="para"><sup class="para">[1] </sup></a>And it is possible that a programmer writing the same script twice will not write the same script!</p></div><div id="ftn.mikmod_for_java" class="footnote"><p><a href="#mikmod_for_java" class="para"><sup class="para">[2] </sup></a>I did in fact convert an entire C codebase (MikMod) to Java through several stages of C++. This took a lot of time, and the resultant code was completely not compatible with the Java conventions. If I had to make MikMod play nice with C++, all I needed were a few extern "C" declarations.</p></div></div></section><footer><div class="navfooter"><hr/><table style="width:100%"><tr><td style="width:40%;text-align:left"><a accesskey="p" href="author.xhtml">Prev</a> </td><td style="width:20%;text-align:center"> </td><td style="width:40%;text-align:right"> <a accesskey="n" href="oop_features.xhtml">Next</a></td></tr><tr><td style="width:40%;text-align:left;vertical-align:top">Author </td><td style="width:20%;text-align:center"><a accesskey="h" href="index.xhtml">Home</a></td><td style="width:40%;text-align:right;vertical-align:top"> Object Oriented Programming Features</td></tr></table></div></footer></body></html>
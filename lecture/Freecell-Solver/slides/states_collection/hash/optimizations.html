<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-GB" lang="en-GB"><head><meta charset="utf-8"/><link rel="stylesheet" href="../../style.css" type="text/css"/><link rel="prev" href="function.html"/><link rel="next" href="../../moves/"/><title>Hash Optimizations</title></head><body><main><header><h1>3.6.2. Hash Optimizations</h1></header><nav><table class="page-nav-bar top"><tr><td><a href="../../" class="nav" accesskey="c">Contents</a></td><td><a href="./" class="nav" accesskey="u">Up</a></td><td><a href="function.html" class="nav" accesskey="p">Prev</a></td><td><a href="../../moves/" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="../../">Freecell Solver - Evolution of a C Program</a> → <a href="../">Evolution of the States' Collection</a> → <a href="./">A Hash Table</a> → <a href="optimizations.html">Hash Optimizations</a></div></nav><ul class="point"><li>Storing the (non-moduloed) hash values along with the keys. That way, the hash values can be compared first before comparing the entire keys.</li><li>Moving elements that were successfully hit to the start of their chains.</li><li>When rehashing (= extending the hash to a greater number of buckets), use the same malloc'ed elements, only re-link them to their new followers.</li></ul><hr/></main><nav><table class="page-nav-bar bottom"><tr><td><a href="../../" class="nav">Contents</a></td><td><a href="./" class="nav">Up</a></td><td><a href="function.html" class="nav">Prev</a></td><td><a href="../../moves/" class="nav">Next</a></td></tr></table></nav><p>Written by <a href="http://www.shlomifish.org/">Shlomi Fish</a></p><footer></footer></body></html>
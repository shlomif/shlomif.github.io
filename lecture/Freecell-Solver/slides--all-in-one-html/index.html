<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-GB" lang="en-GB"><head><meta charset="utf-8"/><link rel="stylesheet" href="style.css" type="text/css"/><title>Freecell Solver - Evolution of a C Program</title></head><body><section class="page"><header><h2 id="page--DIR">Freecell Solver - Evolution of a C Program</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><b>Up</b></td><td><b>Prev</b></td><td><a href="#page--intro--DIR" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Freecell Solver - Evolution of a C Program</a></div></nav><ul class="contentsmain"><li><a href="#page--intro--DIR" class="contents">1. Introduction</a><ul class="contents"><li><a href="#page--intro--rules--DIR" class="contents">1.1. Rules of the Game</a><ul class="contents"><li><a href="#page--intro--rules--strategies--PAGE" class="contents">1.1.1. Common Strategies</a></li></ul></li><li><a href="#page--intro--disclaimer--PAGE" class="contents">1.2. Copyrights and Disclaimer</a></li></ul></li><li><a href="#page--0.2--DIR" class="contents">2. Freecell Solver 0.2's Architecture</a><ul class="contents"><li><a href="#page--0.2--scan--PAGE" class="contents">2.1. The Scan that was used</a></li></ul></li><li><a href="#page--states_collection--DIR" class="contents">3. Evolution of the States' Collection</a><ul class="contents"><li><a href="#page--states_collection--list--PAGE" class="contents">3.1. Initial Perl Version - Flat List</a></li><li><a href="#page--states_collection--qsorted_sort_margin--PAGE" class="contents">3.2. First C Version - Sorted Array</a></li><li><a href="#page--states_collection--b_search_merge--PAGE" class="contents">3.3. Binary-Search-Based Merge to Add the Sort Margin</a></li><li><a href="#page--states_collection--array_of_ptrs--PAGE" class="contents">3.4. Array of Pointers</a></li><li><a href="#page--states_collection--balanced_binary_tree--PAGE" class="contents">3.5. A Balanced Binary Tree</a></li><li><a href="#page--states_collection--hash--DIR" class="contents">3.6. A Hash Table</a><ul class="contents"><li><a href="#page--states_collection--hash--function--PAGE" class="contents">3.6.1. The Choice of a Hash Function</a></li><li><a href="#page--states_collection--hash--optimizations--PAGE" class="contents">3.6.2. Hash Optimizations</a></li></ul></li></ul></li><li><a href="#page--moves--DIR" class="contents">4. Moves Management</a><ul class="contents"><li><a href="#page--moves--meta--PAGE" class="contents">4.1. Meta-Moves (instead of Atomic ones)</a></li><li><a href="#page--moves--stack-to-stack--PAGE" class="contents">4.2. Stack to Stack Moves</a></li><li><a href="#page--moves--generalization--PAGE" class="contents">4.3. More Moves Generalization</a></li><li><a href="#page--moves--non-solvable-deals--PAGE" class="contents">4.4. Non-Solvable Deals</a></li></ul></li><li><a href="#page--scans--DIR" class="contents">5. Scanning</a><ul class="contents"><li><a href="#page--scans--tests_order--PAGE" class="contents">5.1. Specifying the Order of Tests</a></li><li><a href="#page--scans--befs--PAGE" class="contents">5.2. Best-First Search</a></li><li><a href="#page--scans--soft_dfs--PAGE" class="contents">5.3. Soft DFS</a></li><li><a href="#page--scans--brfs_optimization--PAGE" class="contents">5.4. The BrFS Optimization Scan</a></li></ul></li><li><a href="#page--state_representation--DIR" class="contents">6. The State Representation</a><ul class="contents"><li><a href="#page--state_representation--data_type_diet--PAGE" class="contents">6.1. Reducing the Data Type Bit-Width</a></li><li><a href="#page--state_representation--ptrs_to_stacks--PAGE" class="contents">6.2. Pointers to Stacks</a></li><li><a href="#page--state_representation--original_indices--DIR" class="contents">6.3. Remembering the Original Stack and Freecell Locations</a><ul class="contents"><li><a href="#page--state_representation--original_indices--solution--PAGE" class="contents">6.3.1. Solution</a></li></ul></li></ul></li><li><a href="#page--board_gen--PAGE" class="contents">7. Board Auto-Generators</a></li><li><a href="#page--why_not_cpp--PAGE" class="contents">8. Why not C++?</a></li><li><a href="#page--flame_war--PAGE" class="contents">9. The fc-solve-discuss flame-war</a></li><li><a href="#page--api--PAGE" class="contents">10. The story of the user API</a></li><li><a href="#page--autoconf--PAGE" class="contents">11. Auto-confisication and Friends</a></li><li><a href="#page--freshmeat_effect--PAGE" class="contents">12. The Freshmeat Effect (and how to avoid it)</a></li><li><a href="#page--finale--DIR" class="contents">13. Finale</a><ul class="contents"><li><a href="#page--finale--links--PAGE" class="contents">13.1. Links and References</a></li><li><a href="#page--finale--book--PAGE" class="contents">13.2. Freecell Solver - EoaCP - The Book</a></li></ul></li></ul><hr/></section><section class="page"><header><h2 id="page--intro--DIR">1. Introduction</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--DIR" class="nav" accesskey="p">Prev</a></td><td><a href="#page--intro--rules--DIR" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--intro--DIR">Introduction</a></div></nav><ul class="point"><li>I wrote the first version of <a href="http://fc-solve.shlomifish.org/">Freecell Solver</a> during a Spring break, because I was interested to find out if a design I thought about would work.</li><li>Since then, it saw 13 major versions, each one adding more features or improving the overall speed or memory consumption.</li><li>In this lecture, I would like to tell about some of the changes I embodied in the program, many of which would be relevant to programming different applications.</li></ul><hr/></section><section class="page"><header><h2 id="page--intro--rules--DIR">1.1. Rules of the Game</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--intro--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--intro--DIR" class="nav" accesskey="p">Prev</a></td><td><a href="#page--intro--rules--strategies--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--intro--DIR">Introduction</a> → <a href="#page--intro--rules--DIR">Rules of the Game</a></div></nav><ul class="point"><li>There are 8 stacks of cards, 4 freecells, and 4 foundations. The game is played with one deck.</li><li>At the beginning of play, the cards are dealt to the stacks (4*7+4*6). The faces of all the cards are visible at the beginning of play.</li><li>A freecell can hold one <b>single</b> card.</li><li>The foundations are built from ace to king and the object of the game is to move all the cards to the foundations.</li><li>A card can be placed on top of a card that is of the opposite colour, and is higher in rank by 1, assuming the latter is at the top of a stack.</li><li>An empty stack may be filled with any card.</li><li>An atomic move consists of:<br/><ul><li>Moving a card from a stack to a vacant freecell.</li><li>Moving a card from a freecell to a parent card on a stack.</li><li>Moving a card from the top of a stack, on top of a parent card on a different stack.</li><li>Moving a card from the top of a stack or from a freecell to the foundations.</li></ul></li></ul><hr/></section><section class="page"><header><h2 id="page--intro--rules--strategies--PAGE">1.1.1. Common Strategies</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--intro--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--intro--rules--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--intro--rules--DIR" class="nav" accesskey="p">Prev</a></td><td><a href="#page--intro--disclaimer--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--intro--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--intro--rules--DIR">Introduction</a> → <a href="#page--intro--rules--DIR">Rules of the Game</a> → <a href="#page--intro--rules--strategies--PAGE">Common Strategies</a></div></nav><ul class="point"><li>A sequence of more than one card can be moved by moving the top cards to the freecells or to unoccupied stacks. This is commonly called a sequence move or a <i>supermove</i> if it involves temporarily putting some cards in a vacant stack.</li><li>Sometimes, it is useful to move cards to the freecells or temporarily to an empty column, so the card below them can serve as a basis for a sequence.</li></ul><hr/></section><section class="page"><header><h2 id="page--intro--disclaimer--PAGE">1.2. Copyrights and Disclaimer</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--intro--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--intro--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--intro--rules--strategies--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--0.2--DIR" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--intro--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--intro--DIR">Introduction</a> → <a href="#page--intro--disclaimer--PAGE">Copyrights and Disclaimer</a></div></nav><p>Freecell Solver was available under the public domain when this talk was originally written (now it is under the <a href="https://en.wikipedia.org/wiki/MIT_License#Variants">MIT/Expat licence</a>). This lecture, on the other hand, has now been licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="license">the Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)</a> (or at your option any later version). reserved.</p><p>I hereby disclaim any damage that reading this work may cause you, either implicit or explicit, direct or indirect.</p><hr/></section><section class="page"><header><h2 id="page--0.2--DIR">2. Freecell Solver 0.2's Architecture</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--intro--disclaimer--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--0.2--scan--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--0.2--DIR">Freecell Solver 0.2's Architecture</a></div></nav><ul class="contentsmain"><li><a href="#page--0.2--scan--PAGE" class="contents">2.1. The Scan that was used</a></li></ul><hr/></section><section class="page"><header><h2 id="page--0.2--scan--PAGE">2.1. The Scan that was used</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--0.2--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--0.2--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--0.2--DIR" class="nav" accesskey="p">Prev</a></td><td><a href="#page--states_collection--DIR" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--0.2--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--0.2--DIR">Freecell Solver 0.2's Architecture</a> → <a href="#page--0.2--scan--PAGE">The Scan that was used</a></div></nav><h2>Pseudo-Code</h2><pre>
Solve-State(state, prev_states, ret)
    if (state == empty_state)
        Push(ret, state)
        return SOLVED
    for each move possible on state
        new_state &lt;- apply(state, move)
        if (new_state in prev_states)
            ; Do nothing
        else
            add new_state to prev_states
            if (Solve-State(new_state, prev_states, ret) == SOLVED)
                Push(ret, state)
                return SOLVED
    return UNSOLVED

Freecell-Solver(init_state)
    if (Solve-State(init_state, Null, ret) == SOLVED)
        print "State was solved"
        while (state &lt;- Pop(ret))
            print state
    else
        print "I could not solve this board";

</pre><ul class="point"><li>It's actually a Depth-First Search (DFS) scan.</li></ul><hr/></section><section class="page"><header><h2 id="page--states_collection--DIR">3. Evolution of the States' Collection</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--0.2--scan--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--states_collection--list--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--states_collection--DIR">Evolution of the States' Collection</a></div></nav><ul class="point"><li>In order to search efficiently we need to keep a collection of states which we encountered so far.</li><li>That is so they (and their derived states) won't be traversed to again and again.</li><li>But how do we manage this collection?</li></ul><ul class="contentsmain"><li><a href="#page--states_collection--list--PAGE" class="contents">3.1. Initial Perl Version - Flat List</a></li><li><a href="#page--states_collection--qsorted_sort_margin--PAGE" class="contents">3.2. First C Version - Sorted Array</a></li><li><a href="#page--states_collection--b_search_merge--PAGE" class="contents">3.3. Binary-Search-Based Merge to Add the Sort Margin</a></li><li><a href="#page--states_collection--array_of_ptrs--PAGE" class="contents">3.4. Array of Pointers</a></li><li><a href="#page--states_collection--balanced_binary_tree--PAGE" class="contents">3.5. A Balanced Binary Tree</a></li><li><a href="#page--states_collection--hash--DIR" class="contents">3.6. A Hash Table</a><ul class="contents"><li><a href="#page--states_collection--hash--function--PAGE" class="contents">3.6.1. The Choice of a Hash Function</a></li><li><a href="#page--states_collection--hash--optimizations--PAGE" class="contents">3.6.2. Hash Optimizations</a></li></ul></li></ul><hr/></section><section class="page"><header><h2 id="page--states_collection--list--PAGE">3.1. Initial Perl Version - Flat List</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--states_collection--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--states_collection--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--states_collection--DIR" class="nav" accesskey="p">Prev</a></td><td><a href="#page--states_collection--qsorted_sort_margin--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--states_collection--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--states_collection--DIR">Evolution of the States' Collection</a> → <a href="#page--states_collection--list--PAGE">Initial Perl Version - Flat List</a></div></nav><ul class="point"><li>An unordered list of states.</li><li>Insertion is O(1), but lookup is O(n).</li><li>Dirt Slow.</li><li>As a general rule O(n) lookup is a very bad idea.</li></ul><hr/></section><section class="page"><header><h2 id="page--states_collection--qsorted_sort_margin--PAGE">3.2. First C Version - Sorted Array</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--states_collection--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--states_collection--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--states_collection--list--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--states_collection--b_search_merge--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--states_collection--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--states_collection--DIR">Evolution of the States' Collection</a> → <a href="#page--states_collection--qsorted_sort_margin--PAGE">First C Version - Sorted Array</a></div></nav><ul class="point"><li>I kept a sorted array of states.</li><li>New states were added to the end of the array, which was kept momentarily unsorted.</li><li>After a few of them were collected, they were added to the main array using qsort.</li><li>O(log(n)) lookup and O(n*log(n)) - O(n<sup><small>2</small></sup>) addition.</li><li>Reasonable performance for most boards.</li></ul><hr/></section><section class="page"><header><h2 id="page--states_collection--b_search_merge--PAGE">3.3. Binary-Search-Based Merge to Add the Sort Margin</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--states_collection--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--states_collection--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--states_collection--qsorted_sort_margin--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--states_collection--array_of_ptrs--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--states_collection--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--states_collection--DIR">Evolution of the States' Collection</a> → <a href="#page--states_collection--b_search_merge--PAGE">Binary-Search-Based Merge to Add the Sort Margin</a></div></nav><ul class="point"><li>Instead of qsorting the sort margin in, keep it sorted and then use a binary-search based merge to merge it with the main array.</li><li>The reason I used a binary search based merge, instead of a linear merge, is because I reasoned that the main array would become much larger than the margin (which has a constant size), and so this would result in a lot of comparisons.</li><li>O(log(n)) lookup, O(n) insertion, and O(n<sup><small>2</small></sup>) accumulative complexity.</li><li>Noticeably faster than qsorting.</li></ul><hr/></section><section class="page"><header><h2 id="page--states_collection--array_of_ptrs--PAGE">3.4. Array of Pointers</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--states_collection--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--states_collection--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--states_collection--b_search_merge--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--states_collection--balanced_binary_tree--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--states_collection--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--states_collection--DIR">Evolution of the States' Collection</a> → <a href="#page--states_collection--array_of_ptrs--PAGE">Array of Pointers</a></div></nav><ul class="point"><li>Version 0.2 of Freecell Solver stored the states in a flat array of structs.</li><li>I converted it into an array of pointers to dynamically allocated structs, due to the fact that I ran out of stack on Windows NT when passing the arrays to functions as parameters.</li><li>This had the happy effect of making the program much faster.</li><li>Reason: Sorting an array of pointers is much faster than sorting an array of structs, because a pointer is considerably smaller.</li></ul><hr/></section><section class="page"><header><h2 id="page--states_collection--balanced_binary_tree--PAGE">3.5. A Balanced Binary Tree</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--states_collection--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--states_collection--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--states_collection--array_of_ptrs--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--states_collection--hash--DIR" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--states_collection--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--states_collection--DIR">Evolution of the States' Collection</a> → <a href="#page--states_collection--balanced_binary_tree--PAGE">A Balanced Binary Tree</a></div></nav><ul class="point"><li>A balanced binary tree is a a tree that is explicitly kept balanced.</li><li>It has a lookup and insertion complexity of O(log(n)), and an accumulative complexity of O(n*log(n)). All of them worst case!</li><li>I only had a general idea how to implement them, but I was able to find predefined open-source APIs on the web that could do the job for me: <a href="http://www.stanford.edu/~blp/avl/">libavl</a>, <a href="http://libredblack.sourceforge.net/">libredblack</a>, <a href="http://library.gnome.org/devel/glib/stable/glib-Balanced-Binary-Trees.html#glib-Balanced-Binary-Trees.synopsis">GLib's Balanced Binary Tree</a>.</li><li>It turned out to be faster than the sorted array, by about a factor of 2.</li></ul><hr/></section><section class="page"><header><h2 id="page--states_collection--hash--DIR">3.6. A Hash Table</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--states_collection--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--states_collection--balanced_binary_tree--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--states_collection--hash--function--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--states_collection--DIR">Evolution of the States' Collection</a> → <a href="#page--states_collection--hash--DIR">A Hash Table</a></div></nav><h2>Can we do better than O(n*log(n))?</h2><ul class="point"><li>If we want to keep the states sorted - no.</li><li>If, however, we just want to determine if a given state is present or not, then the answer is: "usually".</li></ul><h2>What is a hash?</h2><ul class="point"><li>As far as we are concerned a hash is an array of <b>buckets</b>. The index of the bucket into which a given state goes is determined according to a deterministic hash function.</li><li>A hash function is highly magical and should make sure similar records have very distinct hash values, and all hash values are generated in roughly equal frequency.</li></ul><hr/></section><section class="page"><header><h2 id="page--states_collection--hash--function--PAGE">3.6.1. The Choice of a Hash Function</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--states_collection--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--states_collection--hash--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--states_collection--hash--DIR" class="nav" accesskey="p">Prev</a></td><td><a href="#page--states_collection--hash--optimizations--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--states_collection--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--states_collection--hash--DIR">Evolution of the States' Collection</a> → <a href="#page--states_collection--hash--DIR">A Hash Table</a> → <a href="#page--states_collection--hash--function--PAGE">The Choice of a Hash Function</a></div></nav><ul class="point"><li>The first hash function I tried to use with GLib's hash was a function that did a 4-byte wide XOR checksum on the data.</li><li>The performance of the hash was horrible, much more than anything else I tried.</li><li>I then switched to <a href="http://userpages.umbc.edu/~mabzug1/cs/md5/md5.html">MD5</a> and so it performed much better.</li><li>After some time, I realized MD5 was a relatively slow, cryptologically secure, hash function, and I could find faster functions.</li><li>Perl's hash function performed at least equally as well.</li><li>Your hash is only as good as your hash function!</li></ul><hr/></section><section class="page"><header><h2 id="page--states_collection--hash--optimizations--PAGE">3.6.2. Hash Optimizations</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--states_collection--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--states_collection--hash--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--states_collection--hash--function--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--moves--DIR" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--states_collection--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--states_collection--hash--DIR">Evolution of the States' Collection</a> → <a href="#page--states_collection--hash--DIR">A Hash Table</a> → <a href="#page--states_collection--hash--optimizations--PAGE">Hash Optimizations</a></div></nav><ul class="point"><li>Storing the (non-moduloed) hash values along with the keys. That way, the hash values can be compared first before comparing the entire keys.</li><li>Moving elements that were successfully hit to the start of their chains.</li><li>When rehashing (= extending the hash to a greater number of buckets), use the same malloc'ed elements, only re-link them to their new followers.</li></ul><hr/></section><section class="page"><header><h2 id="page--moves--DIR">4. Moves Management</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--states_collection--hash--optimizations--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--moves--meta--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--moves--DIR">Moves Management</a></div></nav><ul class="contentsmain"><li><a href="#page--moves--meta--PAGE" class="contents">4.1. Meta-Moves (instead of Atomic ones)</a></li><li><a href="#page--moves--stack-to-stack--PAGE" class="contents">4.2. Stack to Stack Moves</a></li><li><a href="#page--moves--generalization--PAGE" class="contents">4.3. More Moves Generalization</a></li><li><a href="#page--moves--non-solvable-deals--PAGE" class="contents">4.4. Non-Solvable Deals</a></li></ul><hr/></section><section class="page"><header><h2 id="page--moves--meta--PAGE">4.1. Meta-Moves (instead of Atomic ones)</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--moves--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--moves--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--moves--DIR" class="nav" accesskey="p">Prev</a></td><td><a href="#page--moves--stack-to-stack--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--moves--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--moves--DIR">Moves Management</a> → <a href="#page--moves--meta--PAGE">Meta-Moves (instead of Atomic ones)</a></div></nav><ul class="point"><li>Starting from the early versions, I decided to use <b>meta-moves</b> instead of <b>atomic moves</b>.</li><li>Namely, I do several moves at once while trying to achieve a certain "desirable" end in mind.</li><li>Examples:<br/><ul><li>Put top stack cards in the foundations.</li><li>Put Freecell cards in the foundations.</li><li>Put non-top stack cards in the foundations. (by moving cards above them to freecells or vacant stacks).</li><li>Move stack cards to different stacks.</li><li>Move sequences of cards onto free stacks.</li></ul></li></ul><hr/></section><section class="page"><header><h2 id="page--moves--stack-to-stack--PAGE">4.2. Stack to Stack Moves</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--moves--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--moves--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--moves--meta--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--moves--generalization--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--moves--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--moves--DIR">Moves Management</a> → <a href="#page--moves--stack-to-stack--PAGE">Stack to Stack Moves</a></div></nav><ul class="point"><li>To test the initial versions I generated a 1000 test boards.</li><li>I noticed some of them were not solvable.</li><li>I played some of them manually, and noticed they were solvable using a move that I missed.</li><li>The latter was a meta-move that placed a card on a parent card on the same stack</li><li>By implementing it, all of my boards turned out to be solvable.</li></ul><hr/></section><section class="page"><header><h2 id="page--moves--generalization--PAGE">4.3. More Moves Generalization</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--moves--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--moves--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--moves--stack-to-stack--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--moves--non-solvable-deals--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--moves--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--moves--DIR">Moves Management</a> → <a href="#page--moves--generalization--PAGE">More Moves Generalization</a></div></nav><ul class="point"><li>Someone reported that some of the Microsoft boards were reported as unsolvable by FCS.</li><li>I realized some of my meta-moves were not generic enough so I generalized them.</li><li>Now, Freecell Solver can solve all of the Microsoft deals (except 11982 which was reported to be unsolvable by any human or computerized solver).</li><li>Somewhat later, <a href="http://members.tripod.com/professor_tom/">Tom Holroyd</a> reported a few <a href="http://sonicca.home.dk3.com/cardz/games/s/sea_towers/">"Seahaven Towers"</a> boards which he generated to be unsolvable.</li><li>Once again I was able to improve the solver to accommodate for solving them.</li></ul><hr/></section><section class="page"><header><h2 id="page--moves--non-solvable-deals--PAGE">4.4. Non-Solvable Deals</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--moves--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--moves--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--moves--generalization--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--scans--DIR" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--moves--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--moves--DIR">Moves Management</a> → <a href="#page--moves--non-solvable-deals--PAGE">Non-Solvable Deals</a></div></nav><ul class="point"><li>Adrian Ettlinger sent me a few layouts he tested, with fewer Freecells than usual, that Freecell Solver could not solve.</li><li>I realized that the reason Freecell Solver could not solve them was that a meta-move moved two cards in the opposite manner that would allow for a solution.</li><li>The only way I could think of to solve this without messing my code completely would be to code move functions that would simply perform atomic moves.</li><li>It was not done, yet.</li></ul><hr/></section><section class="page"><header><h2 id="page--scans--DIR">5. Scanning</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--moves--non-solvable-deals--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--scans--tests_order--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--scans--DIR">Scanning</a></div></nav><ul class="point"><li>Freecell Solver first implemented only a regular Depth-First Search scan using procedural recursion.</li><li>The scan performed all the types of meta-moves in one static order.</li><li>As time progressed, I found it desirable to make the scans more flexible.</li></ul><ul class="contentsmain"><li><a href="#page--scans--tests_order--PAGE" class="contents">5.1. Specifying the Order of Tests</a></li><li><a href="#page--scans--befs--PAGE" class="contents">5.2. Best-First Search</a></li><li><a href="#page--scans--soft_dfs--PAGE" class="contents">5.3. Soft DFS</a></li><li><a href="#page--scans--brfs_optimization--PAGE" class="contents">5.4. The BrFS Optimization Scan</a></li></ul><hr/></section><section class="page"><header><h2 id="page--scans--tests_order--PAGE">5.1. Specifying the Order of Tests</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--scans--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--scans--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--scans--DIR" class="nav" accesskey="p">Prev</a></td><td><a href="#page--scans--befs--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--scans--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--scans--DIR">Scanning</a> → <a href="#page--scans--tests_order--PAGE">Specifying the Order of Tests</a></div></nav><ul class="point"><li>A test is a function that attempts to generate new boards using meta-moves.</li><li>Each test used to be implemented in its own separate block of code, but they were only run one by one.</li><li>Later on, they were put in separate functions, each was assigned an ID, and the user could specify in what order to run them (or a subset of them).</li><li>Choosing a good subset turned out to solve some difficult to solve boards, very quickly.</li></ul><hr/></section><section class="page"><header><h2 id="page--scans--befs--PAGE">5.2. Best-First Search</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--scans--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--scans--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--scans--tests_order--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--scans--soft_dfs--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--scans--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--scans--DIR">Scanning</a> → <a href="#page--scans--befs--PAGE">Best-First Search</a></div></nav><ul class="point"><li>Best-First Search is a type of scan that:<ol><li>Gives priority to each state based on some weight function.</li><li>Determines which state to go to next, according to their highest priority.</li></ol></li><li>I implemented Best-First Search whose weight function was a linear combination of several weighting functions I thought about.</li><li>It turned out that for most boards, I could find some relative weights that could solve it very quickly, but no configuration was good for any board.</li></ul><hr/></section><section class="page"><header><h2 id="page--scans--soft_dfs--PAGE">5.3. Soft DFS</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--scans--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--scans--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--scans--befs--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--scans--brfs_optimization--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--scans--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--scans--DIR">Scanning</a> → <a href="#page--scans--soft_dfs--PAGE">Soft DFS</a></div></nav><ul class="point"><li>PySol board No. 980662 recursed into a depth of over 3000. On Win32, this caused a stack overflow which resulted in an ugly segfault.</li><li>I decided to implement a Soft-DFS scan which does not utilize procedural recursion but rather its own dedicated stack.</li><li>This turned out to have an O(1) suspend and resume time instead of O(d) for hard-DFS.</li><li>(I later on discovered that a Win32 program can be compiled with more stack space, but I still think Soft-DFS is a better idea.</li></ul><hr/></section><section class="page"><header><h2 id="page--scans--brfs_optimization--PAGE">5.4. The BrFS Optimization Scan</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--scans--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--scans--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--scans--soft_dfs--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--state_representation--DIR" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--scans--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--scans--DIR">Scanning</a> → <a href="#page--scans--brfs_optimization--PAGE">The BrFS Optimization Scan</a></div></nav><ul class="point"><li><a href="http://www.itm.mu-luebeck.de/~coolo/">Stephan Kulow</a> (of KDE fame) complained that Freecell Solver generated some extremely long solutions, which just moved sequences from one stack to the the other.</li><li>I suggested to use a Breadth-First Search scan restricted to the states that were found in the solution path to try to eliminate redundant moves.</li><li>This turned out to be quite beneficial in most cases.</li><li>I later on implemented a scheme in which each state stored a pointer to its "parent" state (the state from which it was initially discovered). and used back-tracking to trace the solution down there.</li><li>This turned out to optimize solutions as well, but the BrFS optimization improved it a bit too sometimes.</li></ul><hr/></section><section class="page"><header><h2 id="page--state_representation--DIR">6. The State Representation</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--scans--brfs_optimization--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--state_representation--data_type_diet--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--state_representation--DIR">The State Representation</a></div></nav><ul class="contentsmain"><li><a href="#page--state_representation--data_type_diet--PAGE" class="contents">6.1. Reducing the Data Type Bit-Width</a></li><li><a href="#page--state_representation--ptrs_to_stacks--PAGE" class="contents">6.2. Pointers to Stacks</a></li><li><a href="#page--state_representation--original_indices--DIR" class="contents">6.3. Remembering the Original Stack and Freecell Locations</a><ul class="contents"><li><a href="#page--state_representation--original_indices--solution--PAGE" class="contents">6.3.1. Solution</a></li></ul></li></ul><hr/></section><section class="page"><header><h2 id="page--state_representation--data_type_diet--PAGE">6.1. Reducing the Data Type Bit-Width</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--state_representation--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--state_representation--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--state_representation--DIR" class="nav" accesskey="p">Prev</a></td><td><a href="#page--state_representation--ptrs_to_stacks--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--state_representation--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--state_representation--DIR">The State Representation</a> → <a href="#page--state_representation--data_type_diet--PAGE">Reducing the Data Type Bit-Width</a></div></nav><ul class="point"><li>When Freecell Solver started it represented each card and stack length specifier as a 32-bit quantity.</li><li>This caused it to run out of memory or stack in some cases.</li><li>To resolve it, I converted it to use 8-bit bytes.</li><li>This did not only consume less memory but also made it much faster.</li><li>I <a href="http://www.mail-archive.com/linux-il@cs.huji.ac.il/msg07076.html">queried</a> the Linux-IL mailing-list about it and received some answers.</li><li><p>The most probable reasons: less memory -&gt; less cache misses, and handling bytes is just as fast as handling ints.</p><ul><li><p><b>Update:</b> It may also have to do with the limited size of the CPU <a href="https://en.wikipedia.org/wiki/CPU_cache#CACHE-LINES">cache lines</a>, typically 32 bytes on 32-bit x86 CPUs. The more items fit into a cache lines, the less cache misses there are.</p></li></ul></li></ul><hr/></section><section class="page"><header><h2 id="page--state_representation--ptrs_to_stacks--PAGE">6.2. Pointers to Stacks</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--state_representation--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--state_representation--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--state_representation--data_type_diet--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--state_representation--original_indices--DIR" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--state_representation--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--state_representation--DIR">The State Representation</a> → <a href="#page--state_representation--ptrs_to_stacks--PAGE">Pointers to Stacks</a></div></nav><ul class="point"><li>I wanted to add support for such games as Der Katzenschwanz and Die Schlange in which stacks could be initialized to several dozens of cards.</li><li>That made stacks way too long and caused every board to consume a lot of memory.</li><li>Solution: keep one copy of each stack once in a dynamically allocated memory.</li><li>Each state contains an array of pointers to each of its stacks.</li><li>That made it possible to scale up to a million states and more.</li></ul><hr/></section><section class="page"><header><h2 id="page--state_representation--original_indices--DIR">6.3. Remembering the Original Stack and Freecell Locations</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--state_representation--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--state_representation--ptrs_to_stacks--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--state_representation--original_indices--solution--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--state_representation--DIR">The State Representation</a> → <a href="#page--state_representation--original_indices--DIR">Remembering the Original Stack and Freecell Locations</a></div></nav><ul class="point"><li>In Freecell, it is possible that several similar states would be reached, that are only different in the order of the stacks or of the freecells.</li><li>To solve this, I sorted the stacks and the freecells.</li><li>This, however, made the run-time display of the states display them with a confused order.</li></ul><hr/></section><section class="page"><header><h2 id="page--state_representation--original_indices--solution--PAGE">6.3.1. Solution</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--state_representation--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--state_representation--original_indices--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--state_representation--original_indices--DIR" class="nav" accesskey="p">Prev</a></td><td><a href="#page--board_gen--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--state_representation--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--state_representation--original_indices--DIR">The State Representation</a> → <a href="#page--state_representation--original_indices--DIR">Remembering the Original Stack and Freecell Locations</a> → <a href="#page--state_representation--original_indices--solution--PAGE">Solution</a></div></nav><ul class="point"><li>Keep the indices of the stacks and freecells outside the main state data-structure and sort the two arrays together. (i.e: in a struct that contains the stacks-and-freecells struct as its first member)</li><li>The collection considers only the first sizeof(internal) bytes when comparing two states.</li><li>I later used this external information place to store other information like depth in the search tree, the parent state, etc.</li></ul><hr/></section><section class="page"><header><h2 id="page--board_gen--PAGE">7. Board Auto-Generators</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--state_representation--original_indices--solution--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--why_not_cpp--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--board_gen--PAGE">Board Auto-Generators</a></div></nav><ul class="point"><li>A short time after the release of Freecell Solver 0.2.0, Eric Warmenhoven sent me a program he prepared to generate the initial boards of GNOME Freecell so they can later be input into Freecell Solver.</li><li>I thanked him for his effort, and decided to continue the theme.</li><li>So I wrote similar programs to generate the board layouts of GNOME AisleRiot, PySol, and the Microsoft Freecell/Freecell Pro deals (the latter are considered the standard among hard-core Freecell enthusiasts).</li><li>Some programs have integrated the Freecell Solver library to allow for automatically solving a board starting at a position that the player has reached.</li></ul><hr/></section><section class="page"><header><h2 id="page--why_not_cpp--PAGE">8. Why not C++?</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--board_gen--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--flame_war--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--why_not_cpp--PAGE">Why not C++?</a></div></nav><p><a href="http://www.oberhumer.com/mfx/">Markus Oberhumer</a> (of <a href="http://www.oberhumer.com/opensource/pysol/">PySol</a> fame) asked if I thought about converting Freecell Solver to C++. (I suppose he meant with STL, templates and all). Here is a full answer why I'm not going to do it:</p><ol class="point"><li>The solver is already working in C.</li><li>The code is not overly object-oriented. Whatever OOP concepts exist there fit well enough within what C gives me.</li><li>C++/STL may make it slower, perhaps even considerably. I'd rather not spend time risking something like that, only to roll it back later.</li><li>C compiles much faster. (at least with gcc)</li><li>C is cleaner, more portable and causes less unexpected problems than C++.</li></ol><p>I'm more willing to integrate C++-derived features there into the C code. Things like namespaces, (non-inherited) classes, or inline functions. However, for the time being, I'd like to maintain the code as pure C.</p><p>For that matter, some of the gcc extensions can prove very useful too, but I cannot use them either.</p><hr/></section><section class="page"><header><h2 id="page--flame_war--PAGE">9. The fc-solve-discuss flame-war</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--why_not_cpp--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--api--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--flame_war--PAGE">The fc-solve-discuss flame-war</a></div></nav><ul class="point"><li>Recent versions of Freecell Solver pass the moves from the initial position to the final solution to the layer above them.</li><li>The stack -&gt; stack moves are being outputted with the number of cards that are moved.</li><li>Freecell Pro, on the other hand, used to ignore the number of cards and expected such moves to comply with what the original Microsoft Freecell would do in that case.</li><li>This caused problems in playback of a large percentage of the games in its integration with Freecell Solver.</li><li><a href="http://groups.yahoo.com/group/fc-solve-discuss/message/197">A post</a> I made to the mailing list about it sparked a very big flame war that diverted to cover related topics.</li><li><a href="http://groups.yahoo.com/group/fc-solve-discuss/message/219">I was actually happy</a> that there was some action there.</li><li>Usually the only things that happen there is that I announce new releases or ask the members questions and no-one or few people reply.</li><li>Eventually, Adrian Ettlinger (an FC-Pro hacker) have extended Freecell Pro to make use of an optional number of cards to move argument. This made playback of Freecell Solver solutions perfectly smooth.</li></ul><hr/></section><section class="page"><header><h2 id="page--api--PAGE">10. The story of the user API</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--flame_war--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--autoconf--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--api--PAGE">The story of the user API</a></div></nav><ul class="point"><li>Starting of Freecell Solver 1.0.0, FCS had a set of functions called freecell_solver_user_ (after their prefix) which were meant for integration into a larger software needing solving capabilities.</li><li>When Stephan Kulow integrated Freecell Solver into kpat (a solitaire suite for KDE), he did not use it, because it did not give him everything he needed. Instead, he used the more basic internal functions.</li><li>I told him that I "would sleep better at night" knowing that fcs_user_ will be used, and asked him to implement the missing parts himself, and send me the patch. He did.</li><li>Markus Oberhumer (of PySol fame), created a Python interface for the library, and again sent me some functions he wrote.</li><li>Eventually, I converted the command line executable itself to use fcs_user (while adding a lot of functions in the process) to make sure I give the embedding application all of the functionality that I use.</li><li>I also ended up creating an API to analyse a command line and configure a solver instance accordingly.</li><li>Sometimes later, I found it encouraging that Dave Wilkinson, an engineer who worked on Freecell 3D, was able to integrate fcs_user_ without my help, and just informed me of its release.</li><li>The importance of the <a href="http://www.joelonsoftware.com/articles/fog0000000012.html">"Eating your own Dog-Food"</a> concept cannot be stressed enough.</li></ul><hr/></section><section class="page"><header><h2 id="page--autoconf--PAGE">11. Auto-confisication and Friends</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--api--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--freshmeat_effect--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--autoconf--PAGE">Auto-confisication and Friends</a></div></nav><ul class="point"><li>Once upon a time, Freecell Solver was distributed only with a makefile for GNU make, and everyone were happy.</li><li>When Stephan Kulow embedded its code into kpat, he adapted the makefile to use the standard KDE Autoconf-based build process.</li><li>Somewhat afterwards, I decided that I want the build process to be more portable and modular, and to give users the ability to build a shared library.</li><li>The solution - converting to Autoconf, Automake and Libtool.</li><li>How to do that exactly is out of the scope of this lecture. I can just say that it is not very straightforward, and that it required a lot of tweaking and trial and error.</li><li>I then decided that having an RPM of Freecell Solver would be nice. So I created an RPM spec for it.</li><li>Again, it required quite a lot of tweaking and experimenting. (<a href="http://www.haifux.org/lectures/31/">Tzafrir Cohen's Lecture</a> and various web-resources were a great help)</li><li>I eventually integrated generating an up-to-date RPM SPEC into the Autoconf process, and thus, was able to build an RPM by issuing a constant sequence of commands.</li><li>A corresponding Debian package has been initially created by Yotam Rubin and is now maintained by Risko Gergely, who also uploads it to the Debian pool of packages.</li></ul><hr/></section><section class="page"><header><h2 id="page--freshmeat_effect--PAGE">12. The Freshmeat Effect (and how to avoid it)</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--autoconf--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--finale--DIR" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--freshmeat_effect--PAGE">The Freshmeat Effect (and how to avoid it)</a></div></nav><ul class="point"><li>When I created the first version of FCS, and gave it the final touches, I decided to call it "Freecell Solver" in order for it to have a descriptive title.</li><li>I posted announcements for the first release, and subsequent (usually stable) releases on <a href="http://freshmeat.net/">Freshmeat</a>, and so made many people aware of it.</li><li>Starting at the very first days, a <a href="http://www.google.com/search?q=freecell%20solver">Google search for "freecell solver"</a> yielded its homepage as the first link.</li><li>Today, the situation is much worse: now most of the Google hits of this query have something to do with it.</li><li>The query "freecell solver" is generic enough that someone may wish to find any of the available Freecell solvers.</li><li>Solution: do your best to give an original name for your program, so it won't clog up searches.</li></ul><hr/></section><section class="page"><header><h2 id="page--finale--DIR">13. Finale</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--freshmeat_effect--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--finale--links--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--finale--DIR">Finale</a></div></nav><p>I hoped you enjoy the lecture, and that it brought or reminded you of important programming insights, as much as developing the program was beneficial for me in this regard.</p><ul class="contentsmain"><li><a href="#page--finale--links--PAGE" class="contents">13.1. Links and References</a></li><li><a href="#page--finale--book--PAGE" class="contents">13.2. Freecell Solver - EoaCP - The Book</a></li></ul><hr/></section><section class="page"><header><h2 id="page--finale--links--PAGE">13.1. Links and References</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--finale--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--finale--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--finale--DIR" class="nav" accesskey="p">Prev</a></td><td><a href="#page--finale--book--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--finale--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--finale--DIR">Finale</a> → <a href="#page--finale--links--PAGE">Links and References</a></div></nav><h2>Freecell Solver Links</h2><ul><li><a href="http://fc-solve.shlomifish.org/">The Freecell Solver Homepage</a></li><li><a href="http://fc-solve.shlomifish.org/">A Mirror at BerliOS</a></li><li><a href="http://freshmeat.net/projects/freecellsolver/">Freshmeat Record</a></li></ul><h2>People who were Involved in the Development</h2><ul><li><a href="http://www.kdedevelopers.org/blog/124">Stephan Kulow</a></li><li><a href="http://members.tripod.com/professor_tom/">Tom Holroyd</a></li><li><a href="http://www.solitairelaboratory.com/">Michael Keller</a></li></ul><h2>Relevant <a href="http://www.JoelOnSoftware.com/">"Joel On Software"</a> articles</h2><ul><li><a href="http://www.joelonsoftware.com/articles/fog0000000043.html">The Joel Test</a> - building a package in one step, fixing bugs before writing new code and other stuff.</li><li><a href="http://www.joelonsoftware.com/articles/fog0000000012.html">Eating your own Dog Food</a> - the importance of using your own software.</li><li><a href="http://www.joelonsoftware.com/articles/fog0000000020.html">Bloatware and the 80/20 Myth</a> - why a feature-rich software needs all its features.</li><li><a href="http://www.joelonsoftware.com/articles/fog0000000069.html">Things you should never do, Part I</a> - why re-writing an entire codebase from scratch is a bad idea.</li><li><a href="http://www.joelonsoftware.com/articles/fog0000000319.html">Back to Basics</a> - about O(n) lookups and unnecessarily increasing a program's complexity by an order of n.</li><li><a href="http://www.JoelOnSoftware.com/articles/FiveWorlds.html">Five Worlds</a> - about the differences between Shrink-wrap software, one for internal use, throwaway, embedded and games.</li><li><b>Note:</b> Joel's articles are mostly relevant to commercial, market-place software, and should be taken with a grain of salt in regard to writing voluntary, open-source one. (and should be taken with a grain of salt in any case, because he seems very opinionated)</li></ul><h2>General Freecell Links</h2><ul><li><a href="http://www.solitairelaboratory.com/fcfaq.html">The Freecell FAQ</a> - a comprehensive document answering many commonly asked questions about Freecell and the Microsoft Deals</li><li><a href="http://www.cs.ruu.nl/~hansb/d.freecell/freecellhtml.html">An unsolvable Freecell deal</a> - with proof.</li></ul><hr/></section><section class="page"><header><h2 id="page--finale--book--PAGE">13.2. Freecell Solver - EoaCP - The Book</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--finale--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--finale--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--finale--links--PAGE" class="nav" accesskey="p">Prev</a></td><td><b>Next</b></td></tr></table><div class="bread"><a href="#page--finale--DIR">Freecell Solver - Evolution of a C Program</a> → <a href="#page--finale--DIR">Finale</a> → <a href="#page--finale--book--PAGE">Freecell Solver - EoaCP - The Book</a></div></nav><p><b>Update:</b> I originally planned to write a book, but abandoned that idea for various reasons. You can find a <a href="https://fc-solve.shlomifish.org/book.html">copy of the latest draft</a> of the book and <a href="https://fc-solve.shlomifish.org/docs/">some other documentation</a> on the Freecell Solver site</p><p>Enjoy!</p><hr/></section></body></html>
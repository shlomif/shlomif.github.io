<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-GB" lang="en-GB"><head><meta charset="utf-8"/><link rel="stylesheet" href="style.css" type="text/css"/><title>Software Development under Linux</title></head><body><section class="page"><header><h2 id="page--DIR">Software Development under Linux</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><b>Up</b></td><td><b>Prev</b></td><td><a href="#page--why--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Software Development under Linux</a></div></nav><p>In this lecture we are going to cover what you need to know in order to start programming in C/C++ in a Linux environment. We will cover the following:</p><ul class="contentsmain"><li><a href="#page--why--PAGE" class="contents">1. Why Program under Linux? (Briefly)</a></li><li><a href="#page--gcc--DIR" class="contents">2. Use of gcc/g++</a><ul class="contents"><li><a href="#page--gcc--flags--PAGE" class="contents">2.1. Important gcc Flags</a></li><li><a href="#page--gcc--gpp--PAGE" class="contents">2.2. g++</a></li></ul></li><li><a href="#page--makefiles--DIR" class="contents">3. Writing Makefiles</a><ul class="contents"><li><a href="#page--makefiles--basics--PAGE" class="contents">3.1. Makefile Basics</a></li><li><a href="#page--makefiles--variables--PAGE" class="contents">3.2. Makefile Variables</a></li><li><a href="#page--makefiles--notes--PAGE" class="contents">3.3. Final Notes</a></li></ul></li><li><a href="#page--emacs--DIR" class="contents">4. The Almighty Emacs</a><ul class="contents"><li><a href="#page--emacs--more--PAGE" class="contents">4.1. More Emacs</a></li><li><a href="#page--emacs--yet-more--PAGE" class="contents">4.2. Yet More Emacs</a></li><li><a href="#page--emacs--end--PAGE" class="contents">4.3. Emacs - The End (Well at Least the Last Slide)</a></li></ul></li><li><a href="#page--gdb--DIR" class="contents">5. The gdb Debugger</a><ul class="contents"><li><a href="#page--gdb--basic--PAGE" class="contents">5.1. Basic gdb Commands</a></li></ul></li><li><a href="#page--ddd--DIR" class="contents">6. DDD - The Data Display Debugger</a><ul class="contents"><li><a href="#page--ddd--tips--PAGE" class="contents">6.1. DDD Debugging Tips</a></li></ul></li><li><a href="#page--valgrind--DIR" class="contents">7. valgrind - a Good Tool to Detect Memory Problems</a><ul class="contents"><li><a href="#page--valgrind--more--PAGE" class="contents">7.1. More Valgrind</a></li></ul></li></ul><h2 id="license">License</h2><p>This document is Copyright by Meir Maor, 2004, and is available under the terms of <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">the Creative Commons Attribution-ShareAlike License 4.0 Unported</a> (or at your option any later version). Whatever source code is provided is under <a href="https://opensource.org/licenses/BSD-3-Clause">BSD-3-Clause</a></p><p>Shlomi Fish hereby places his changes under <a href="https://creativecommons.org/licenses/by/4.0/">CC-by 4.0-or later</a> with source code changes under BSD-3-Clause.</p><hr/></section><section class="page"><header><h2 id="page--why--PAGE">1. Why Program under Linux? (Briefly)</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--DIR" class="nav" accesskey="p">Prev</a></td><td><a href="#page--gcc--DIR" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Software Development under Linux</a> → <a href="#page--why--PAGE">Why Program under Linux? (Briefly)</a></div></nav><p class="point">There are many reasons, the most important IMHO are:</p><ul class="point"><li>Stable environment; makes it hard to mess up too badly,</li><li>Good tools, ANSI compliant. Work less and get more done.</li><li>Portable code. What you write using GNU tools will work anywhere.</li><li>A nice little Unix system at home.</li><li>Open source environment.</li></ul><hr/></section><section class="page"><header><h2 id="page--gcc--DIR">2. Use of gcc/g++</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--why--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--gcc--flags--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Software Development under Linux</a> → <a href="#page--gcc--DIR">Use of gcc/g++</a></div></nav><ul class="point"><li>gcc is the GNU compiler collection, originally called GNU C compiler.</li><li>gcc is commonly invoked from the command line, like so:<br/><code class="cmd">gcc [ option | filename ]...</code><br/></li><li>This is correct but, probably means nothing to you, one would normally use gcc like so:<br/><code class="cmd">gcc [flags] file1 [file2 [file3 ...]] [-o output_file]</code><br/>where file1 file2 etc. are input files, either C source files or pre-compiled object files.</li><li>Example: <code>gcc foo1.c foo2.c -o foo</code></li><li>The default executable output filename is a.out. When producing object files, the default output for each input file has the suffix .o .</li></ul><hr/></section><section class="page"><header><h2 id="page--gcc--flags--PAGE">2.1. Important gcc Flags</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--gcc--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--gcc--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--gcc--DIR" class="nav" accesskey="p">Prev</a></td><td><a href="#page--gcc--gpp--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--gcc--DIR">Software Development under Linux</a> → <a href="#page--gcc--DIR">Use of gcc/g++</a> → <a href="#page--gcc--flags--PAGE">Important gcc Flags</a></div></nav><table style="border-width:thin;border-color:#000"><tr><td><code>-ansi</code></td><td>This flag tells the compiler to enforce ANSI C standards</td></tr><tr><td><code>-pedantic</code></td><td>More pedantic ansi, warnings for stuff you probably didn't mean.</td></tr><tr><td><code>-Wall</code></td><td>Show all reasonable warnings (there are more).</td></tr><tr><td><code>-g</code></td><td>Produce debug information, necessary for debugging.</td></tr><tr><td><code>-l<span style="color:red">library</span></code></td><td>Links to a standard library. Use <code>-l<span style="color:red">m</span></code> to load the standard maths library.</td></tr><tr><td><code>-c</code></td><td>Compile or assemble the source files, but do not link. The compiler output is object files corresponding to each source file.</td></tr><tr><td><code>-S</code></td><td>Compile only; output assembly code.</td></tr><tr><td><code>-E</code></td><td>Pre-process only. Output pre-processed code.</td></tr><tr><td><code>-D<span style="color:red">macro</span></code></td><td>Define a macro, one can also use <code>-D<span style="color:red">macro</span>=<span style="color:red">val</span></code> in order to assign a value for the macro. This will be used for preprocessing all files.</td></tr></table><ul class="point"><li>When compiling, I recommend (and Kimchi demands) compiling with:<br/><code class="cmd">gcc -ansi -pedantic -Wall file1 [file2 [file3...]] -o output</code></li></ul><hr/></section><section class="page"><header><h2 id="page--gcc--gpp--PAGE">2.2. g++</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--gcc--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--gcc--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--gcc--flags--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--makefiles--DIR" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--gcc--DIR">Software Development under Linux</a> → <a href="#page--gcc--DIR">Use of gcc/g++</a> → <a href="#page--gcc--gpp--PAGE">g++</a></div></nav><ul class="point"><li>g++ is actually a script which calls gcc with the appropriate options in order to compile C++. Standard suffixes for C++ source files are: <code>.C</code>, <code>.cc</code>, <code>.cxx</code>, <code>.cpp</code>, or <code>.c++</code>.</li><li>I recommend using g++ like so:<br/><code class="cmd">g++ -Wall file1 [file2 [file3...]] -o output_file</code></li></ul><hr/></section><section class="page"><header><h2 id="page--makefiles--DIR">3. Writing Makefiles</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--gcc--gpp--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--makefiles--basics--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Software Development under Linux</a> → <a href="#page--makefiles--DIR">Writing Makefiles</a></div></nav><ul class="point"><li>Makefiles are a way to define how your project is to be built.</li><li>The make tool reads this file and compiles your project properly and efficiently, recompiling files that were changed and files which depend on them using the correct compile command at each stage.</li><li>For large projects this is a must, and in many cases it is convenient also for small projects with only half a dozen source files.</li></ul><hr/></section><section class="page"><header><h2 id="page--makefiles--basics--PAGE">3.1. Makefile Basics</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--makefiles--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--makefiles--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--makefiles--DIR" class="nav" accesskey="p">Prev</a></td><td><a href="#page--makefiles--variables--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--makefiles--DIR">Software Development under Linux</a> → <a href="#page--makefiles--DIR">Writing Makefiles</a> → <a href="#page--makefiles--basics--PAGE">Makefile Basics</a></div></nav><ul class="point"><li>A makefile is built out of a set of targets which we want to build and intermediate targets used in the build process.</li><li>In a makefile, the target is followed by a colon (:), which is then followed by a list of its dependent targets or files (commonly referred to as dependencies). Afterwards in a new line, there should be a tab character (and not any other whitespace before or afterwards), followed by the command used to generate the target from the dependencies.</li></ul><h2>Example</h2><div class="mycode"><pre>
<span class="c31">foo</span>: foo.o helper.o
    gcc -Wall foo.o helper.o -o foo

<span class="c31">bar</span>: bar.o helper.o
    gcc -Wall bar.o helper.o -o bar

<span class="c31">bar.o</span>: bar.c
    gcc bar.c -c -o bar

<span class="c31">foo.o</span>: foo.c foo.h
    gcc -ansi -Wall -c foo.c -o foo.o
</pre></div><ul class="point"><li>To run make one types: <code>make [target_name]</code></li><li>If no target is specified the first target in the makefile is used.</li></ul><hr/></section><section class="page"><header><h2 id="page--makefiles--variables--PAGE">3.2. Makefile Variables</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--makefiles--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--makefiles--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--makefiles--basics--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--makefiles--notes--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--makefiles--DIR">Software Development under Linux</a> → <a href="#page--makefiles--DIR">Writing Makefiles</a> → <a href="#page--makefiles--variables--PAGE">Makefile Variables</a></div></nav><ul class="point"><li>We can define variables in makefiles to make the writing shorter and the modifications easier.</li><li>Rewriting the previous makefile with variables and extra targets:</li></ul><div class="mycode"><pre>
<span class="c31">CC</span>= gcc
<span class="c31">LD</span>= gcc
<span class="c31">CC_FLAGS </span>= -ansi -Wall -c
<span class="c31">LD_FLAGS </span>= -Wall

<span class="c31">all</span>: foo bar

<span class="c31">foo</span>: foo.o helper.o
    <span class="c31">$(LD)</span> <span class="c31">$(LD_FLAGS)</span> foo.o helper.o -o foo
<span class="c31">bar</span>: bar.o helper.o
    <span class="c31">$(LD)</span> <span class="c31">$(LD_FLAGS)</span> bar.o helper.o -o bar

<span class="c31">bar.o</span>: bar.c
    <span class="c31">$(CC)</span> <span class="c31">$(CC_FLAGS)</span> bar.c
<span class="c31">foo.o</span>: foo.c foo.h
    <span class="c31">$(CC)</span> <span class="c31">$(CC_FLAGS)</span> foo.c

<span class="c31">clean</span>: rm -f *.o foo bar
</pre></div><hr/></section><section class="page"><header><h2 id="page--makefiles--notes--PAGE">3.3. Final Notes</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--makefiles--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--makefiles--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--makefiles--variables--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--emacs--DIR" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--makefiles--DIR">Software Development under Linux</a> → <a href="#page--makefiles--DIR">Writing Makefiles</a> → <a href="#page--makefiles--notes--PAGE">Final Notes</a></div></nav><h2>How Make Works</h2><ul class="point"><li>Makefiles watch the time-stamps for files, if the source files time stamps are newer than the target, the target needs to be rebuilt and any targets depending on it need to be rebuilt as well.</li></ul><h2>More Information</h2><ul class="point"><li>More information on makefiles can be found in the info file, accessible via the <code>pinfo make</code> command, or by typing: <code>info:make</code> in the Konqueror address line.</li></ul><hr/></section><section class="page"><header><h2 id="page--emacs--DIR">4. The Almighty Emacs</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--makefiles--notes--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--emacs--more--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Software Development under Linux</a> → <a href="#page--emacs--DIR">The Almighty Emacs</a></div></nav><ul class="point"><li>Emacs is my recommended editor. There are some who prefer VI. IMHO they tend to be masochistic.</li><li>First of all, Emacs like everything under linux has good documentation. When you run <code>emacs</code> type <code>C-h t</code> (that is <code>Control+h</code> and then <code>t</code>), and you will get to an emacs tutorial (that can also be found in the help menu)</li><li>emacs usually allows moving around using the arrow keys and page_up/down keys but it always allows another better way which does not involve moving your fingers from the normal typing position. It will take getting use to but eventually will work much faster.</li><li>Basic movement with the arrow keys can be replaced with:</li></ul><table class="center"><tr><td colspan="2"></td><td>Previous Line: <code>C-p</code></td><td colspan="2"></td></tr><tr><td colspan="2"></td><td>::</td><td colspan="2"></td></tr><tr><td>Backward: <code>C-b</code></td><td>...</td><td>Current Cursor Position</td><td>...</td><td>Forward: <code>C-f</code></td></tr><tr><td colspan="2"></td><td>::</td><td colspan="2"></td></tr><tr><td colspan="2"></td><td>Next Line: <code>C-n</code></td><td colspan="2"></td></tr></table><hr/></section><section class="page"><header><h2 id="page--emacs--more--PAGE">4.1. More Emacs</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--emacs--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--emacs--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--emacs--DIR" class="nav" accesskey="p">Prev</a></td><td><a href="#page--emacs--yet-more--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--emacs--DIR">Software Development under Linux</a> → <a href="#page--emacs--DIR">The Almighty Emacs</a> → <a href="#page--emacs--more--PAGE">More Emacs</a></div></nav><ul class="point"><li>One could also use <code>M-f</code> and <code>M-b</code> to move one word at a time instead of one character at a time.</li><li>M is short for the Meta key, on your keyboard it will probably be Alt.</li><li>Page up is <code>M-v</code>. Page Down is <code>C-v</code>.</li><li>End of Line is <code>C-e</code>. Beginning of the Line is <code>C-a</code>.</li><li>So much for moving around.</li><li>The most common method of copy&amp;paste is by cutting out using <code>C-k</code>. C-k cuts until the end of line, typing <code>C-k</code> many times will cut many lines. If you cut a few lines then move around and cut more lines. The first lines would be lost this way (not including possible undo).</li><li>In order to paste we will yank the text out of the buffer using <code>C-y</code> you can yank(paste) out however many times you want wherever you want.</li></ul><hr/></section><section class="page"><header><h2 id="page--emacs--yet-more--PAGE">4.2. Yet More Emacs</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--emacs--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--emacs--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--emacs--more--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--emacs--end--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--emacs--DIR">Software Development under Linux</a> → <a href="#page--emacs--DIR">The Almighty Emacs</a> → <a href="#page--emacs--yet-more--PAGE">Yet More Emacs</a></div></nav><ul class="point"><li>At this point we should mention <code>C-x u</code> which is the undo option it will undo the last act. You can do several of these in a row, notice there is a big difference between <code>C-x u</code> and <code>C-x C-u</code> you must let go of the Ctrl key, before hitting the <code>u</code> key.</li><li>Handling files and buffers can be done with menus on top but also with shortcuts: opening a file is with <code>C-x C-f</code> you can use the tab to complete file names as you can in the bash/tcsh command prompt.</li><li>When executing emacs from the command line you can give it a file name as a parameter, in both cases emacs will create a new file should the file not exist.</li><li>Saving is done by <code>C-x C-s</code> which saves the current buffer(file) or <code>C-x s</code> which will prompt to verify and save each and every open buffer.</li><li>One exits emacs with <code>C-x C-c</code>.</li></ul><hr/></section><section class="page"><header><h2 id="page--emacs--end--PAGE">4.3. Emacs - The End (Well at Least the Last Slide)</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--emacs--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--emacs--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--emacs--yet-more--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--gdb--DIR" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--emacs--DIR">Software Development under Linux</a> → <a href="#page--emacs--DIR">The Almighty Emacs</a> → <a href="#page--emacs--end--PAGE">Emacs - The End (Well at Least the Last Slide)</a></div></nav><ul class="point"><li>Basic search in emacs is done with <code>C-s</code>.</li><li>Search and replace is done with <code>M-%</code>.</li><li>Emacs does syntax highlighting. You can easily enable this by selecting it in the Options menu.</li><li>Emacs will align your source code automatically. You can use the tab key to re-align a specific line. Always re-align from top to bottom.</li><li>You can recompile your code while inside Emacs. Type <code>M-x compile</code>. A new buffer will open and it will display compilation results. You can go through them easily while having your cursor jump to where the errors are using <code>C-x `</code>. (backquote).</li><li>To maximize the current buffer to cover all of the Emacs window use <code>C-x 1</code>, (<code>C-x 2</code> will split the buffer)</li><li>We will look at a little example program that we will edit &amp; compile with Emacs: <a href="#page--emacs--test.c--DIR">test.c</a>.</li><li>A useful time saver: expand abbreviations with <code>M-/</code>.</li></ul><hr/></section><section class="page"><header><h2 id="page--gdb--DIR">5. The gdb Debugger</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--emacs--end--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--gdb--basic--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Software Development under Linux</a> → <a href="#page--gdb--DIR">The gdb Debugger</a></div></nav><ul class="point"><li>gdb is the basic debugger. Many Linux debuggers are based on it.</li><li>Even though it does not have a fancy GUI, it does the trick.</li><li><b>In order to use gdb one must use the -g flag when compiling!</b></li><li>Executing gdb is simple: <code>gdb program_name</code> (it can be run differently but for that RTFM)</li><li>gdb has an excellent built in help, you can type <code>help</code> from the gdb command line and get a list of stuff to get help on, or type <code>help &lt;something&gt;</code>, and get specific help on something - either a command or a topic name.</li><li>Another good source for help on gdb is the info pages. Type: <code>pinfo gdb</code> or <code>info gdb</code> if <code>pinfo</code> is not available.</li></ul><hr/></section><section class="page"><header><h2 id="page--gdb--basic--PAGE">5.1. Basic gdb Commands</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--gdb--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--gdb--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--gdb--DIR" class="nav" accesskey="p">Prev</a></td><td><a href="#page--ddd--DIR" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--gdb--DIR">Software Development under Linux</a> → <a href="#page--gdb--DIR">The gdb Debugger</a> → <a href="#page--gdb--basic--PAGE">Basic gdb Commands</a></div></nav><table class="gdb"><tr><td><code>run</code></td><td>Executes the program from the beginning. You can use: <code>run &lt; file_in &gt; file_out</code> to redirect I/O for the program being executed.</td></tr><tr><td><code>break</code></td><td>Used to set breakpoints. Can be used in many ways:<br/><code>break line_number</code><br/><code>break function_name</code><br/><code>break file_name:line_number</code><br/><code>break class::method</code></td></tr><tr><td><code>next</code></td><td>Proceed one command line while not entering function calls.</td></tr><tr><td><code>step</code></td><td>Proceed one command line, step into function calls if necessary.</td></tr><tr><td><code>cont</code></td><td>Continue until next breakpoint.</td></tr><tr><td><code>where</code></td><td>Display call stack.</td></tr><tr><td><code>print</code></td><td>Print a variable or an expression. Used <code>print expression</code></td></tr><tr><td><code>up/down</code></td><td>Move up and down in the call stack. Allows you to examine local variables of previous functions.</td></tr></table><ul class="point"><li>And many more (see the help).</li></ul><hr/></section><section class="page"><header><h2 id="page--ddd--DIR">6. DDD - The Data Display Debugger</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--gdb--basic--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--ddd--tips--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Software Development under Linux</a> → <a href="#page--ddd--DIR">DDD - The Data Display Debugger</a></div></nav><ul class="point"><li>DDD is a powerful tool which is a graphical interface for an inferior debugger (usually gdb). DDD can do everything your favourite debugger can and much more.</li><li>You can watch the code and execute it line by line and examine data.</li><li>The speciality of DDD as its name might suggest is its ability to display your programs data graphically in a very comfortable manner.</li><li>DDD will allow you to display structures and dereference pointers to create a visualization of a linked-list or a tree. DDD can also create graphs out of arrays.</li><li>DDD has a gdb command line, so anyone who can use gdb can use DDD and gradually learn its special features.</li><li>A little test program: <a href="#page--ddd--testddd.c--DIR">testddd.c</a>.</li></ul><hr/></section><section class="page"><header><h2 id="page--ddd--tips--PAGE">6.1. DDD Debugging Tips</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--ddd--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--ddd--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--ddd--DIR" class="nav" accesskey="p">Prev</a></td><td><a href="#page--valgrind--DIR" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--ddd--DIR">Software Development under Linux</a> → <a href="#page--ddd--DIR">DDD - The Data Display Debugger</a> → <a href="#page--ddd--tips--PAGE">DDD Debugging Tips</a></div></nav><ul class="point"><li>Right click with mouse to the left of code to add/remove breakpoints.</li><li>All gdb commands work from gdb window at bottom of screen.</li><li>When program crashes, first look at stack back-trace,by choosing <code>&lt;menu&gt;-&gt;Status-&gt;Backtrace</code>.</li><li>To display data structures use display section, right-click on a variable and choose display.</li><li>In display section, double click on a pointer to dereference it.</li><li>To have DDD detect the same object is being referenced from two places, type Alt-a. Or <code>&lt;menu&gt;-&gt;Data-&gt;Detect Aliases</code>. In the latest version, this is default behaviour.</li><li>When debugging C++, to avoid stepping into STL functions, one should normally use <code>Next</code>; use <code>Step</code> when you specifically want to step into a function.</li><li>Place mouse over a variable to see its value.</li></ul><hr/></section><section class="page"><header><h2 id="page--valgrind--DIR">7. valgrind - a Good Tool to Detect Memory Problems</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--ddd--tips--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--valgrind--more--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Software Development under Linux</a> → <a href="#page--valgrind--DIR">valgrind - a Good Tool to Detect Memory Problems</a></div></nav><ul class="point"><li>valgrind can detect problems such as:<br/><ul><li>Use of uninitialized memory.</li><li>Reading/writing memory after it has been free'd.</li><li>Reading/writing off the end of malloc'd blocks.</li><li>Reading/writing inappropriate areas on the stack.</li><li>Memory leaks -- where pointers to malloc'd blocks are lost forever.</li><li>Passing of uninitialized and/or unaddressable memory to system calls.</li><li>Mismatched use of malloc/new/new [] Vs free/delete/delete [].</li><li>Some abuses of the POSIX pthreads API.</li></ul></li><li>valgrind is very easy to use. It has many optional flags that you can learn about from the documentation. (<code>valgrind -h</code>).</li><li>A useful flag is <code>--num-callers=<span style="color:red">NNN</span></code> which sets how far back to print the function call sequence when an error is detected, (sometimes the error actually occurs in a sequence of functions you didn't write). By default it is <code>--num-callers=4</code>.</li></ul><hr/></section><section class="page"><header><h2 id="page--valgrind--more--PAGE">7.1. More Valgrind</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--valgrind--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--valgrind--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--valgrind--DIR" class="nav" accesskey="p">Prev</a></td><td><b>Next</b></td></tr></table><div class="bread"><a href="#page--valgrind--DIR">Software Development under Linux</a> → <a href="#page--valgrind--DIR">valgrind - a Good Tool to Detect Memory Problems</a> → <a href="#page--valgrind--more--PAGE">More Valgrind</a></div></nav><ul class="point"><li>Valgrind does not require special compilation. You simply execute it like so: <code>valgrind --num-callers=15 progname</code>. It will run the program <code>progname</code> and intercept calls to malloc/free/new/delete and monitor all memory uses.</li><li>Another useful flag is <code>--gdb-attach=yes</code> that invokes gdb on the process when errors are detected, and let you debug the place of the error.</li><li>Valgrind is good only for x86s running some non-ancient Linux - this shouldn't be much of a problem.</li><li>Valgrind will report several types of errors:<ul><li>Illegal read / illegal write errors.</li><li>Use of uninitialized values.</li><li>Illegal frees.</li><li>Inappropriate deallocation function.</li><li>Passing system call parameters with inadequate read/write permissions.</li></ul></li><li>Valgrind will tell you, when possible, where in your code the relevant memory blocks were allocated/freed.</li><li>Valgrind is most probably not installed on the Linux box you are working on, however installation is trivial and fairly quick: download, unpack and then run one after another:<br/><code>./configure</code><br/><code>make</code><br/><code>make install</code><br/></li><li>Valgrind's manual is available in the distribution directory under <code>docs/index.html</code>.</li></ul><hr/></section></body></html>
<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-GB" lang="en-GB"><head><meta charset="utf-8"/><link rel="stylesheet" href="style.css" type="text/css"/><title>Software Development on Linux</title></head><body><section class="page"><header><h2 id="page--DIR">Software Development on Linux</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><b>Up</b></td><td><b>Prev</b></td><td><a href="#page--devel-process--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Software Development on Linux</a></div></nav><h2>Contents</h2><ul class="contentsmain"><li><a href="#page--devel-process--PAGE" class="contents">1. The Linux Development process</a></li><li><a href="#page--text-editing--DIR" class="contents">2. Editing Text using Text Editors</a><ul class="contents"><li><a href="#page--text-editing--text-nuances--PAGE" class="contents">2.1. Text Nuances</a></li><li><a href="#page--text-editing--editors--PAGE" class="contents">2.2. Recommended Editors for Beginners</a></li><li><a href="#page--text-editing--advanced-editors--PAGE" class="contents">2.3. Advanced Editors</a></li></ul></li><li><a href="#page--gcc--DIR" class="contents">3. Use of gcc/g++</a><ul class="contents"><li><a href="#page--gcc--flags--PAGE" class="contents">3.1. Important gcc Flags</a></li><li><a href="#page--gcc--gpp--PAGE" class="contents">3.2. g++</a></li></ul></li><li><a href="#page--makefiles--DIR" class="contents">4. Writing Makefiles</a><ul class="contents"><li><a href="#page--makefiles--basics--PAGE" class="contents">4.1. Makefile Basics</a></li><li><a href="#page--makefiles--variables--PAGE" class="contents">4.2. Makefile Variables</a></li><li><a href="#page--makefiles--notes--PAGE" class="contents">4.3. Final Notes</a></li></ul></li><li><a href="#page--gdb--DIR" class="contents">5. The gdb Debugger</a><ul class="contents"><li><a href="#page--gdb--basics_cmds--PAGE" class="contents">5.1. Basic gdb Commands</a></li><li><a href="#page--gdb--ddd--DIR" class="contents">5.2. DDD - The Data Display Debugger</a><ul class="contents"><li><a href="#page--gdb--ddd--tips--PAGE" class="contents">5.2.1. DDD Debugging Tips</a></li></ul></li></ul></li><li><a href="#page--valgrind--DIR" class="contents">6. valgrind - a Memory Problems Detector</a><ul class="contents"><li><a href="#page--valgrind--more--PAGE" class="contents">6.1. More Valgrind</a></li></ul></li><li><a href="#page--IDEs--DIR" class="contents">7. Integrated Development Environments</a><ul class="contents"><li><a href="#page--IDEs--alternatives--PAGE" class="contents">7.1. The Various Available Alternatives</a></li></ul></li></ul><h2 id="license">License</h2><p>This document is Copyright by Meir Maor, 2004, and is available under the terms of <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">the Creative Commons Attribution-ShareAlike License 4.0 Unported</a> (or at your option any later version). Whatever source code is provided is under <a href="https://opensource.org/licenses/BSD-3-Clause">BSD-3-Clause</a></p><p>Shlomi Fish hereby places his changes under <a href="https://creativecommons.org/licenses/by/4.0/">CC-by 4.0-or later</a> with source code changes under BSD-3-Clause.</p><hr/></section><section class="page"><header><h2 id="page--devel-process--PAGE">1. The Linux Development process</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--DIR" class="nav" accesskey="p">Prev</a></td><td><a href="#page--text-editing--DIR" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Software Development on Linux</a> → <a href="#page--devel-process--PAGE">The Linux Development process</a></div></nav><ul class="point"><li>Development on Linux takes place by editing text files, running command-line commands to build them into executables (from the command line), and invoking them.</li><li>There is often a debug stage using an interactive debugger.</li><li>Afterwards, one can modify the files and build again.</li></ul><hr/></section><section class="page"><header><h2 id="page--text-editing--DIR">2. Editing Text using Text Editors</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--devel-process--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--text-editing--text-nuances--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Software Development on Linux</a> → <a href="#page--text-editing--DIR">Editing Text using Text Editors</a></div></nav><ul class="contentsmain"><li><a href="#page--text-editing--text-nuances--PAGE" class="contents">2.1. Text Nuances</a></li><li><a href="#page--text-editing--editors--PAGE" class="contents">2.2. Recommended Editors for Beginners</a></li><li><a href="#page--text-editing--advanced-editors--PAGE" class="contents">2.3. Advanced Editors</a></li></ul><hr/></section><section class="page"><header><h2 id="page--text-editing--text-nuances--PAGE">2.1. Text Nuances</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--text-editing--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--text-editing--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--text-editing--DIR" class="nav" accesskey="p">Prev</a></td><td><a href="#page--text-editing--editors--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--text-editing--DIR">Software Development on Linux</a> → <a href="#page--text-editing--DIR">Editing Text using Text Editors</a> → <a href="#page--text-editing--text-nuances--PAGE">Text Nuances</a></div></nav><h2>Tabs and Whitespace</h2><ul class="point"><li>There is a special character called "Tab" whose ASCII value is 9. It is usually displayed as several adjacent whitespace characters.</li><li>In some file-types (most notably Makefiles) tabs have a special meaning and cannot be substituted with their equivalent whitespaces.</li><li>They would even reject a whitespace before the tab. (which often looks identical to a tab).</li><li>Thus it is important to make sure your editor is configured so it inputs tabs at such files.</li></ul><h2>Carriage Returns</h2><ul class="point"><li>On Linux and other UNIX systems, the lines of text files are terminated with a single character called <a href="http://en.wikipedia.org/wiki/Line_feed">"Newline" or "Linefeed"</a>.</li><li>In DOS, and Windows, the Linefeed character is preceded by another character called <a href="http://en.wikipedia.org/wiki/Carriage_return">Carriage Return</a>.</li><li>The problem is that some Linux tools will not tolerate CRs at the end of lines, so they have to be removed somehow.</li><li>You can use the following command: <code>perl -pi -e 's/\r$//' [files]</code> to convert files from DOS-style to Linux/Unix-style.</li></ul><hr/></section><section class="page"><header><h2 id="page--text-editing--editors--PAGE">2.2. Recommended Editors for Beginners</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--text-editing--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--text-editing--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--text-editing--text-nuances--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--text-editing--advanced-editors--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--text-editing--DIR">Software Development on Linux</a> → <a href="#page--text-editing--DIR">Editing Text using Text Editors</a> → <a href="#page--text-editing--editors--PAGE">Recommended Editors for Beginners</a></div></nav><ul class="point"><li>The following text editors are recommended for developers who are new to Linux development:</li></ul><h2>Kate</h2><ul class="point"><li><a href="http://kate.kde.org/">Kate</a> (short for "KDE Advanced Text Editor") is a powerful programmer's editor for the KDE environment.</li><li>It has menus, toolbars, a nice user-interface, syntax highlighting and operates in a Windows-like manner.</li><li>If you have KDE installed, you could give it a try.</li></ul><h2>gedit</h2><ul class="point"><li><a href="http://www.gnome.org/projects/gedit/">gedit</a> is the default GNOME editor, which is also suitable for development.</li><li>Has syntax highlighting, menus and toolbars, syntax highlighting and most other things developers need.</li><li>GNOME is known to deviate from the MS-Windows conventions in some respects, which may prove to be an obstacle to people who convert to it (or to gedit specifically) from Windows.</li></ul><h2>NEdit</h2><ul class="point"><li><a href="http://www.nedit.org/">NEdit</a> is a Powerful, desktop-neutral, programmer's editor.</li><li>Emulates the Windows conventions precisely.</li><li>Has a nice GUI, syntax highlighting, and many powerful features.</li><li>Probably not installed by default and so will require an explicit installation using your distribution's package manager.</li></ul><hr/></section><section class="page"><header><h2 id="page--text-editing--advanced-editors--PAGE">2.3. Advanced Editors</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--text-editing--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--text-editing--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--text-editing--editors--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--gcc--DIR" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--text-editing--DIR">Software Development on Linux</a> → <a href="#page--text-editing--DIR">Editing Text using Text Editors</a> → <a href="#page--text-editing--advanced-editors--PAGE">Advanced Editors</a></div></nav><ul class="point"><li>vi and Emacs are two powerful editors that many hard-core or experienced UNIX developers use.</li><li>Their keyboard conventions and user-interface are not compatible with those of more recent Windows-like editors (or with each other), and they both require some time getting used to.</li><li>Thus, it is recommended that people who have a lot of Windows experience not use them right-away.</li><li>Of the various vi clones, the most powerful, popular and recommended is <a href="http://www.vim.org/">Vim</a> which has a GUI version titled "gvim".</li><li>There are two popular and currently maintained versions of Emacs: <a href="http://www.gnu.org/software/emacs/emacs.html">GNU Emacs</a> and <a href="http://www.xemacs.org/">XEmacs</a>.</li><li>They are all also available for Windows and for other non-UNIX platforms.</li></ul><hr/></section><section class="page"><header><h2 id="page--gcc--DIR">3. Use of gcc/g++</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--text-editing--advanced-editors--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--gcc--flags--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Software Development on Linux</a> → <a href="#page--gcc--DIR">Use of gcc/g++</a></div></nav><ul class="point"><li>gcc is the "GNU Compiler Collection", originally called the "GNU C compiler".</li><li>gcc is commonly invoked from the command line, like so:<br/><code class="cmd">gcc [ option | filename ]...</code><br/></li><li><p>One would normally use gcc like so:</p><p><code class="cmd">gcc [flags] file1 [file2 [file3 ...]] [-o output_file]</code></p><p>Where <code>file1</code> <code>file2</code> etc. are input files, either C source files or pre-compiled object files.</p></li><li>Example: <code>gcc foo1.c foo2.c -o foo</code></li><li>The default executable output filename is <code>a.out</code>. When producing object files, the default output for each input file has the suffix <code>.o</code> .</li></ul><hr/></section><section class="page"><header><h2 id="page--gcc--flags--PAGE">3.1. Important gcc Flags</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--gcc--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--gcc--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--gcc--DIR" class="nav" accesskey="p">Prev</a></td><td><a href="#page--gcc--gpp--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--gcc--DIR">Software Development on Linux</a> → <a href="#page--gcc--DIR">Use of gcc/g++</a> → <a href="#page--gcc--flags--PAGE">Important gcc Flags</a></div></nav><table class="info"><tr><td><code>-ansi</code></td><td>This flag tells the compiler to enforce ANSI C standards</td></tr><tr><td><code>-pedantic</code></td><td>More pedantic ansi, warnings for stuff you probably didn't mean.</td></tr><tr><td><code>-Wall</code></td><td>Show all reasonable warnings (there are more).</td></tr><tr><td><code>-g</code></td><td>Produce debug information, necessary for debugging.</td></tr><tr><td><code>-l<span style="color:red">library</span></code></td><td>Links to a standard library. Use <code>-l<span style="color:red">m</span></code> to load the standard maths library.</td></tr><tr><td><code>-c</code></td><td>Compile or assemble the source files, but do not link. The compiler output is object files corresponding to each source file.</td></tr><tr><td><code>-S</code></td><td>Compile only; output assembly code.</td></tr><tr><td><code>-E</code></td><td>Pre-process only. Output pre-processed code.</td></tr><tr><td><code>-D<span style="color:red">macro</span></code></td><td>Define a macro, one can also use <code>-D<span style="color:red">macro</span>=<span style="color:red">val</span></code> in order to assign a value for the macro. This will be used for preprocessing all files.</td></tr></table><ul class="point"><li>When compiling, I recommend (and Kimchi demands) compiling with:<br/><code class="cmd">gcc -ansi -pedantic -Wall file1 [file2 [file3...]] -o output</code></li></ul><hr/></section><section class="page"><header><h2 id="page--gcc--gpp--PAGE">3.2. g++</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--gcc--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--gcc--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--gcc--flags--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--makefiles--DIR" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--gcc--DIR">Software Development on Linux</a> → <a href="#page--gcc--DIR">Use of gcc/g++</a> → <a href="#page--gcc--gpp--PAGE">g++</a></div></nav><ul class="point"><li>g++ is actually a script which calls gcc with the appropriate options in order to compile C++. Standard suffixes for C++ source files are: <code>.C</code>, <code>.cc</code>, <code>.cxx</code>, <code>.cpp</code>, or <code>.c++</code>.</li><li>I recommend using g++ like so:<br/><code class="cmd">g++ -Wall file1 [file2 [file3...]] -o output_file</code></li></ul><hr/></section><section class="page"><header><h2 id="page--makefiles--DIR">4. Writing Makefiles</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--gcc--gpp--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--makefiles--basics--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Software Development on Linux</a> → <a href="#page--makefiles--DIR">Writing Makefiles</a></div></nav><ul class="point"><li>Makefiles are a way to define how your project is to be built.</li><li>The make tool reads this file and compiles your project properly and efficiently, recompiling files that were changed and files which depend on them using the correct compile command at each stage.</li><li>For large projects this is a must, and in many cases it is convenient also for small projects with only half a dozen source files.</li></ul><hr/></section><section class="page"><header><h2 id="page--makefiles--basics--PAGE">4.1. Makefile Basics</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--makefiles--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--makefiles--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--makefiles--DIR" class="nav" accesskey="p">Prev</a></td><td><a href="#page--makefiles--variables--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--makefiles--DIR">Software Development on Linux</a> → <a href="#page--makefiles--DIR">Writing Makefiles</a> → <a href="#page--makefiles--basics--PAGE">Makefile Basics</a></div></nav><ul class="point"><li>A makefile is built out of a set of targets which we want to build and intermediate targets used in the build process.</li><li>In a makefile, the target is followed by a colon (:), which is then followed by a list of its dependent targets or files (commonly referred to as dependencies).</li><li>Afterwards in a new line, there should be a tab character (and not any other whitespace before or afterwards), followed by the command used to generate the target from the dependencies.</li></ul><h2>Example</h2><div class="mycode"><pre>
foo: foo.o helper.o
    gcc -Wall foo.o helper.o -o foo

bar: bar.o helper.o
    gcc -Wall bar.o helper.o -o bar

bar.o: bar.c
    gcc bar.c -c -o bar

foo.o: foo.c foo.h
    gcc -ansi -Wall -c foo.c -o foo.o

</pre></div><ul class="point"><li>To run make one types: <code>make [target_name]</code></li><li>If no target is specified the first target in the makefile is used.</li></ul><hr/></section><section class="page"><header><h2 id="page--makefiles--variables--PAGE">4.2. Makefile Variables</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--makefiles--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--makefiles--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--makefiles--basics--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--makefiles--notes--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--makefiles--DIR">Software Development on Linux</a> → <a href="#page--makefiles--DIR">Writing Makefiles</a> → <a href="#page--makefiles--variables--PAGE">Makefile Variables</a></div></nav><ul class="point"><li>We can define variables in makefiles to make the writing shorter and the modifications easier.</li><li>Rewriting previous makefile with variables and extra targets.</li></ul><div class="mycode"><pre>
<span class="c31">CC</span>= gcc
<span class="c31">LD</span>= gcc
<span class="c31">CC_FLAGS </span>= -ansi -Wall -c
<span class="c31">LD_FLAGS </span>= -Wall

<span class="c31">all</span>: foo bar

<span class="c31">foo</span>: foo.o helper.o
    <span class="c31">$(LD)</span> <span class="c31">$(LD_FLAGS)</span> foo.o helper.o -o foo
<span class="c31">bar</span>: bar.o helper.o
    <span class="c31">$(LD)</span> <span class="c31">$(LD_FLAGS)</span> bar.o helper.o -o bar

<span class="c31">bar.o</span>: bar.c
    <span class="c31">$(CC)</span> <span class="c31">$(CC_FLAGS)</span> bar.c
<span class="c31">foo.o</span>: foo.c foo.h
    <span class="c31">$(CC)</span> <span class="c31">$(CC_FLAGS)</span> foo.c

<span class="c31">clean</span>:
    rm -f *.o foo bar
</pre></div><hr/></section><section class="page"><header><h2 id="page--makefiles--notes--PAGE">4.3. Final Notes</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--makefiles--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--makefiles--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--makefiles--variables--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--gdb--DIR" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--makefiles--DIR">Software Development on Linux</a> → <a href="#page--makefiles--DIR">Writing Makefiles</a> → <a href="#page--makefiles--notes--PAGE">Final Notes</a></div></nav><h2>How Make Works</h2><ul class="point"><li>Makefiles watch the time-stamps for files, if the source files time stamps are newer than the target, the target needs to be rebuilt and any targets depending on it need to be rebuilt as well.</li></ul><h2>More Information</h2><ul class="point"><li>More information on makefiles can be found in the info file, accessible via the <code>pinfo make</code> command, or by typing: <code>info:make</code> in the Konqueror address line. There is also an <a href="https://www.gnu.org/software/make/manual/">online version of the document</a> on GNU.org.</li></ul><hr/></section><section class="page"><header><h2 id="page--gdb--DIR">5. The gdb Debugger</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--makefiles--notes--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--gdb--basics_cmds--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Software Development on Linux</a> → <a href="#page--gdb--DIR">The gdb Debugger</a></div></nav><ul class="point"><li>gdb is the basic debugger for C and C++. Many Linux debuggers are based on it.</li><li>It is a command line debugger.</li><li><b>In order to use gdb one must use the -g flag when compiling!</b></li><li>Executing gdb is simple: <code>gdb program_name</code>.</li><li>gdb has an excellent built in help, you can type <code>help</code> from the gdb command line and get a list of stuff to get help on, or type <code>help &lt;something&gt;</code>, and get specific help on something - either a command or a topic name.</li><li>Other good sources for help on gdb are <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/">the gdb manual</a>, <a href="http://web.archive.org/web/20071017044810/http://users.actcom.co.il/~choo/lupg/tutorials/debugging/debugging-with-gdb.html">the Little Unix Programming Group's tutorial on gdb</a>, and <a href="http://github.com/shlomif/Freenode-programming-channel-FAQ/blob/master/FAQ.mdwn#how-do-i-learn-how-to-use-gdb--the-gnu-debugger">the Freenode’s programming channel’s FAQ</a>.</li></ul><hr/></section><section class="page"><header><h2 id="page--gdb--basics_cmds--PAGE">5.1. Basic gdb Commands</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--gdb--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--gdb--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--gdb--DIR" class="nav" accesskey="p">Prev</a></td><td><a href="#page--gdb--ddd--DIR" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--gdb--DIR">Software Development on Linux</a> → <a href="#page--gdb--DIR">The gdb Debugger</a> → <a href="#page--gdb--basics_cmds--PAGE">Basic gdb Commands</a></div></nav><table class="gdb"><tr><td><code>run</code></td><td>Executes the program from the beginning. You can use: <code>run &lt; file_in &gt; file_out</code> to redirect I/O for the program being executed.</td></tr><tr><td><code>break</code></td><td>Used to set breakpoints. Can be used in many ways:<br/><code>break line_number</code><br/><code>break function_name</code><br/><code>break file_name:line_number</code><br/><code>break class::method</code></td></tr><tr><td><code>next</code></td><td>Proceed one command line while not entering function calls.</td></tr><tr><td><code>step</code></td><td>Proceed one command line, step into function calls if necessary.</td></tr><tr><td><code>cont</code></td><td>Continue until next breakpoint.</td></tr><tr><td><code>where</code></td><td>Display call stack.</td></tr><tr><td><code>print</code></td><td>Print a variable or an expression. Used <code>print expression</code></td></tr><tr><td><code>up/down</code></td><td>Move up and down in the call stack. Allows you to examine local variables of previous functions.</td></tr></table><ul class="point"><li>And many more (see the help).</li></ul><hr/></section><section class="page"><header><h2 id="page--gdb--ddd--DIR">5.2. DDD - The Data Display Debugger</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--gdb--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--gdb--basics_cmds--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--gdb--ddd--tips--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Software Development on Linux</a> → <a href="#page--gdb--DIR">The gdb Debugger</a> → <a href="#page--gdb--ddd--DIR">DDD - The Data Display Debugger</a></div></nav><ul class="point"><li>DDD is a powerful graphical interface for an inferior command-line debugger (usually gdb). DDD can do everything your favourite debugger can and much more.</li><li>You can watch the code and execute it line by line and examine data.</li><li>The speciality of DDD as its name might suggest is its ability to display your programs data graphically in a very comfortable manner.</li><li>DDD will allow you to display structures and dereference pointers to create a visualization of a linked-list or a tree. DDD can also create graphs out of arrays.</li><li>DDD has a gdb command line, so anyone who can use gdb can use DDD and gradually learn its special features.</li></ul><hr/></section><section class="page"><header><h2 id="page--gdb--ddd--tips--PAGE">5.2.1. DDD Debugging Tips</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--gdb--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--gdb--ddd--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--gdb--ddd--DIR" class="nav" accesskey="p">Prev</a></td><td><a href="#page--valgrind--DIR" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--gdb--DIR">Software Development on Linux</a> → <a href="#page--gdb--ddd--DIR">The gdb Debugger</a> → <a href="#page--gdb--ddd--DIR">DDD - The Data Display Debugger</a> → <a href="#page--gdb--ddd--tips--PAGE">DDD Debugging Tips</a></div></nav><ul class="point"><li>Right click with mouse to the left of code to add/remove breakpoints.</li><li>All gdb commands work from gdb window at bottom of screen.</li><li>When program crashes, first look at stack back-trace,by choosing <code>&lt;menu&gt; → Status → Backtrace</code>.</li><li>To display data structures use display section, right-click on a variable and choose display.</li><li>In display section, double click on a pointer to dereference it.</li><li>To have DDD detect the same object is being referenced from two places, type Alt-a. Or <code>&lt;menu&gt; → Data → Detect Aliases</code>. In the latest version, this is default behaviour.</li><li>When debugging C++, to avoid stepping into STL functions, one should normally use <code>Next</code>; use <code>Step</code> when you specifically want to step into a function.</li><li>Place mouse over a variable to see its value.</li></ul><hr/></section><section class="page"><header><h2 id="page--valgrind--DIR">6. valgrind - a Memory Problems Detector</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--gdb--ddd--tips--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--valgrind--more--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Software Development on Linux</a> → <a href="#page--valgrind--DIR">valgrind - a Memory Problems Detector</a></div></nav><ul class="point"><li>valgrind can detect problems such as:<br/><ul><li>Use of uninitialized memory.</li><li>Reading/writing memory after it has been <code>free()</code>ed.</li><li>Reading/writing off the end of <code>malloc()</code>ed blocks.</li><li>Reading/writing inappropriate areas on the stack.</li><li>Memory leaks -- where pointers to malloc'd blocks are lost forever.</li><li>Passing of uninitialized and/or unaddressable memory to system calls.</li><li>Mismatched use of <code>malloc()</code>/<code>new</code>/<code>new []</code> vs <code>free()</code>/<code>delete</code>/<code>delete []</code>.</li><li>Some abuses of the POSIX pthreads API.</li></ul></li><li>valgrind is very easy to use. It has many optional flags that you can learn about from the documentation. (<code>valgrind -h</code>).</li><li>A useful flag is <code>--num-callers=<span style="color:red">NNN</span></code> which sets how far back to print the function call sequence when an error is detected, (sometimes the error actually occurs in a sequence of functions you didn't write). By default it is <code>--num-callers=4</code>.</li></ul><hr/></section><section class="page"><header><h2 id="page--valgrind--more--PAGE">6.1. More Valgrind</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--valgrind--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--valgrind--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--valgrind--DIR" class="nav" accesskey="p">Prev</a></td><td><a href="#page--IDEs--DIR" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--valgrind--DIR">Software Development on Linux</a> → <a href="#page--valgrind--DIR">valgrind - a Memory Problems Detector</a> → <a href="#page--valgrind--more--PAGE">More Valgrind</a></div></nav><ul class="point"><li>Valgrind does not require special compilation. You simply execute it like so: <code>valgrind --num-callers=15 progname</code>. It will run the program <code>progname</code> and intercept calls to malloc/free/new/delete and monitor all memory uses.</li><li>Another useful flag is <code>--gdb-attach=yes</code> that invokes gdb on the process when errors are detected, and let you debug the place of the error.</li><li>Valgrind works only on x86s running a modern Linux version. (<b>Update:</b> it can now work on other operating systems and architectures as well.)</li><li>Valgrind will report several types of errors:<br/><ul><li>Illegal read / illegal write errors.</li><li>Use of uninitialized values.</li><li>Illegal frees.</li><li>Inappropriate deallocation function.</li><li>Passing system call parameters with inadequate read/write permissions.</li></ul></li><li>Valgrind will tell you, when possible, where in your code the relevant memory blocks were allocated/freed.</li><li>Valgrind is most probably not installed on the Linux box you are working on, however installation is trivial and fairly quick: download, unpack and then run one after another:<br/><code>./configure</code><br/><code>make</code><br/><code>make install</code><br/></li><li>Valgrind's manual is available in the directory of its unpacked distribution under <code>docs/index.html</code>.</li></ul><hr/></section><section class="page"><header><h2 id="page--IDEs--DIR">7. Integrated Development Environments</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--valgrind--more--PAGE" class="nav" accesskey="p">Prev</a></td><td><a href="#page--IDEs--alternatives--PAGE" class="nav" accesskey="n">Next</a></td></tr></table><div class="bread"><a href="#page--DIR">Software Development on Linux</a> → <a href="#page--IDEs--DIR">Integrated Development Environments</a></div></nav><ul class="point"><li>There are also several Integrated Development Environments (or IDEs) that run on Linux.</li></ul><h2>Warning</h2><ul class="point"><li>These development environments tend to enforce their own "integrated" way of doing things on the programmer, and possibly necessitate using other tools, that are not absolutely necessary for simple-minded projects.</li><li>The all differ from similar environments on Windows to some extent.</li><li>If you can get along with one or more of them, that's good, but they may or may not be suitable for you.</li></ul><hr/></section><section class="page"><header><h2 id="page--IDEs--alternatives--PAGE">7.1. The Various Available Alternatives</h2></header><nav><table class="page-nav-bar top"><tr><td><a href="#page--IDEs--DIR" class="nav" accesskey="c">Contents</a></td><td><a href="#page--IDEs--DIR" class="nav" accesskey="u">Up</a></td><td><a href="#page--IDEs--DIR" class="nav" accesskey="p">Prev</a></td><td><b>Next</b></td></tr></table><div class="bread"><a href="#page--IDEs--DIR">Software Development on Linux</a> → <a href="#page--IDEs--DIR">Integrated Development Environments</a> → <a href="#page--IDEs--alternatives--PAGE">The Various Available Alternatives</a></div></nav><h2>KDevelop</h2><ul class="point"><li><a href="http://www.kdevelop.org/">KDevelop</a> is an integrated development environment for the KDE desktop.</li><li>It supports development in C and C++ and in many other languages.</li></ul><h2>Eclipse</h2><ul class="point"><li><a href="http://www.eclipse.org/">Eclipse</a> is an IDE written in Java, and very suitable and popular for Java development.</li><li>Its <a href="http://www.eclipse.org/cdt/">CDT (C/C++ Development Tools)</a> provides an environment for C/C++ programming.</li></ul><h2>Anjuta</h2><ul class="point"><li><a href="http://anjuta.sourceforge.net/">Anjuta</a> is a C and C++ IDE for the GNOME desktop.</li><li>It may still be less powerful than the other two.</li></ul><hr/></section></body></html>
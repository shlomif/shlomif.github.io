<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html><html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><head><title>[untitled]</title><meta charset="utf-8"/><style>body{color:#000;background:#fff none}A:link{color:#00f;background:#fff none}A:visited{color:#909;background:#fff none}A:hover{color:red;background:#fff none}A:active{color:red;background:#fff none}.synComment{color:#00f}.synConstant{color:#f0f}.synIdentifier{color:#008b8b}.synStatement{color:brown;font-weight:700}.synPreProc{color:#a020f0}.synType{color:#2e8b57;font-weight:700}.synSpecial{color:#6a5acd}.synUnderlined{color:#000;text-decoration:underline}.synError{color:#fff;background:red none}.synTodo{color:#00f;background:#ff0 none}</style></head><body><pre><span class="synComment">; Boolean Operations in Lambda Calculus</span>
<span class="synComment">; -------------------------------------</span>

<span class="synComment">; Not:</span>
<span class="synComment">; Think of not(a) as</span>
<span class="synComment">; if a == true</span>
<span class="synComment">;      return false</span>
<span class="synComment">; else</span>
<span class="synComment">;      return true</span>
<span class="synComment">; end</span>
<span class="synComment">; Thus in lc it would become:</span>
(<span class="synStatement">define</span> lc_not
    (<span class="synStatement">lambda</span> (x)
            ((x lc_false) lc_true)
    )
)

<span class="synComment">; And(x,y):</span>
<span class="synComment">; again, think of and as:</span>
<span class="synComment">; if x == true</span>
<span class="synComment">;      if b == true</span>
<span class="synComment">;          return true</span>
<span class="synComment">;      else</span>
<span class="synComment">;           return false</span>
<span class="synComment">;      end</span>
<span class="synComment">; else</span>
<span class="synComment">;      return false</span>
<span class="synComment">; end</span>

(<span class="synStatement">define</span> lc_and
    (<span class="synStatement">lambda</span> (x)
            (<span class="synStatement">lambda</span> (y)
                    ((x ((y lc_true) lc_false)) lc_false)
            )
    )
)

<span class="synComment">; Or(x,y):</span>
<span class="synComment">; if x == true</span>
<span class="synComment">;     return true</span>
<span class="synComment">; else</span>
<span class="synComment">;     if y == true</span>
<span class="synComment">;         return true</span>
<span class="synComment">;     else</span>
<span class="synComment">;         return false</span>
<span class="synComment">;     end</span>
<span class="synComment">; end</span>

(<span class="synStatement">define</span> lc_or
    (<span class="synStatement">lambda</span> (x)
            (<span class="synStatement">lambda</span> (y)
                    ((x lc_true) ((y lc_true) lc_false))
            )
    )
)


<span class="synComment">; Note, as opposed to the &amp;&amp; and || operators in C or the &quot;and&quot; and &quot;or&quot;</span>
<span class="synComment">; statements in Scheme, those ands and ors always evaluate both expressions.</span>
</pre></body></html>
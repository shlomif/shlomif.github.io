<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>The Perfect IT Workplace - Revision 1 - Software Engineering Best Practices</title>
<meta charset="utf-8"/>
<meta name="description" content=
"The Perfect IT Workplace - Revision 1 - Software Engineering Best Practices"/>
<link rel="stylesheet" href="../../../../../faq-indiv.css" media="screen"/>
<link rel="stylesheet" href="../../../../../screenplay.css" media="screen"
title="Normal"/>
<link rel="stylesheet" href="../../../../../print.css" media="print"/>
<link rel="shortcut icon" href="../../../../../favicon.ico" type=
"image/x-icon"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
</head>
<body class="fancy_sects faq_indiv_entry limit_imgs_width screenplay_indiv_entry">
<div class="header" id="header">
<a href="../../../../../"><img src="../../../../../images/evilphish-flipped.png"
alt="EvilPHish site logo"/></a>
<div class="leading_path"><a href="../../../../../">Shlomi Fish’s
Homepage</a> →
<a href="../perfect-it-workplace.xhtml" title="The Perfect IT Workplace - Revision 1">The Perfect IT Workplace - Revision 1</a>
 → <a href="the-elements.xhtml">The Elements of a Perfect Workplace</a>
→ <b>Software Engineering Best Practices</b>
</div>
</div>
<div id="faux">
<main class="main faq screenplay">
<section xmlns="http://www.w3.org/1999/xhtml" class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="software-engineering" class="title">Software Engineering Best Practices</h4><h:a class="back_to_faq" href="../perfect-it-workplace.xhtml#software-engineering">Node Link</h:a></header><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="functional-specs" class="title">Functional Specs</h5></header><p>The first advice I can give is to <a class="link" href="http://www.joelonsoftware.com/articles/fog0000000036.html"><span class="bold"><strong>write functional specs</strong></span></a>. In the link, Joel Spolsky explains the motivation and method of writing functional spec. A functional spec describes how the end-user will use and interact with the program. It is not a technical spec which explains how the inner software will work.</p><p>From my experience, functional specs are fun to write, reveal many problems in the initial design, and make you think how the software will work on the inside.</p><p>Here are three examples for functional specs I wrote:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><a class="link" href="http://svn.berlios.de/svnroot/repos/web-cpan/App-Freelancers-Board-Yonathan/trunk/docs/functional-spec/App-Freelancer-Board-Yonathan-functional-spec.txt">Functional Spec for a Freelancers Board</a> (with a Biblical theme).</p></li><li class="listitem"><p><a class="link" href="http://svn.berlios.de/svnroot/repos/web-cpan/CPAN-Module-Classification/trunk/docs/functional-spec-for-CPAN-Classification-Proposal.txt">Functional Spec for a better classification of CPAN Modules</a> (with a theme of FOSS world celebrities).</p></li><li class="listitem"><p><a class="link" href="http://svn.berlios.de/svnroot/repos/winapt/winapt/trunk/docs/design/functional-spec.txt">Functional Spec for a Windows package management system.</a> (featuring characters from <a class="link" href="http://www.ozyandmillie.org/">Ozy and Millie</a>).</p></li></ol></div></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="automated-tests" class="title">Automated Tests</h5></header><p>You should write automated tests such as unit tests, integration tests, system tests, that will run automatically on the code and yield an answer if all of them are successful, or if any of them fail.</p><p>There are many good practices for automated testing such as having daily builds or reaching a 100% test coverage. Here are some resources to get you started:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="link" href="http://qa.perl.org/">The Perl Quality Assurance project</a>, also see their wiki.</p></li><li class="listitem"><p><a class="link" href="http://en.wikipedia.org/wiki/Software_testing">The Wikipedia page about Software Testing.</a></p></li></ul></div><p>Note that having automated tests is not a substitute for having <a class="link" href="http://www.joelonsoftware.com/articles/fog0000000067.html">dedicated software testers</a> (and vice versa). By all means, they are both necessary for any serious operation.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="design-and-planning" class="title">Design and Planning</h5></header><p>Most people agree that designing a software, planning it and thinking about it is a good idea. Extreme Programming suggests to have one design meeting every day. I personally feel that too much design like that is equivalent to very little of it, but still design and planning should be done</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="refactoring" class="title">Refactoring</h5></header><p><a class="link" href="http://www.refactoring.com/">Refactoring</a> is the process of improving the internal quality of the code (from "a big mess" to "squeaky-clean and modular code"), while not changing its external behaviour. This is done for mostly functional and bug-free, but sub-optimally-written, code so it can be better managed.</p><p>"Joel on Software" features two excellent article about the motivation for refactoring: <a class="link" href="http://www.joelonsoftware.com/articles/fog0000000069.html">"Things You Should Never Do, Part I (why rewriting functional code from scratch is a bad idea)"</a>, and <a class="link" href="http://www.joelonsoftware.com/articles/fog0000000348.html">"Rub a dub dub" (how and why to do refactoring).</a>.</p><p>There are many other resources for that online, along with many refactoring patterns.</p><p>There are many types of refactoring: grand refactoring sessions (= what Joel describes), continuous refactoring (refactoring as you go), "just-in-time refactoring" (refactoring enough to achieve a certain task), etc.</p><p>But refactoring is important, makes development faster in the long run (and even in the short-run), and can prevent the code from deteriorating into an ugly, non-functional mess that would be hard to salvage.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="soft-eng-methods-to-avoid" class="title">Software Engineering Methods to Avoid</h5></header><p>There are few software engineering methods that I find pointless, so I'd like to briefly point them out.</p><p>The first is the <span class="bold"><strong>"Huge-design-up-front"</strong></span>, where an "architect" or even the entire team spends a very long time writing an extremely comprehensive and detailed technical document that specifies in detail how the software will work.</p><p>The problem with this approach is that it is a huge waste of time and also it is impossible to design a large project top-down like that. A better way is to involve the entire team in a good design session (a week long at first) while writing some functional specs, diagrams and some other documents, and then to write it incrementally.</p><p id="extract-method">A similar fallacy is the <span class="bold"><strong>"Mountains of documentation fallacy"</strong></span> of having superfluous commenting, Literate programming, etc. The problem with this approach is that the extra documentation is often redundant if the code is well written and factored out <a href="../perfect-it-workplace.xhtml#ftn.extract-method" class="footnote"><sup class="footnote">[Extract-Method]</sup></a></p><p>Some documentation (especially API documentation such as <a class="link" href="http://en.wikipedia.org/wiki/Plain_Old_Documentation">Perl's POD</a> or <a class="link" href="http://www.doxygen.org/">Doxygen</a>) is good, and you shouldn't feel too guilty about writing a comment for an interesting trick, but too much documentation slows things down, and doesn't help with the design process, and eventually may turn out to be misleading or harmful.</p><p>Something else I consider a bad idea is <a class="link" href="http://en.wikipedia.org/wiki/You_Ain't_Gonna_Need_It">Overengineering or YAGNI ("You Ain't Gonna Need It")</a>. The basic idea is not to implement too many features at once, or over-complicate the design of the code, and instead focus on getting the necessary functionality working.</p><p>YAGNI, put aside, I still believe that some forward-planning is good.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="maintaining-two-codebases" class="title">Maintaining Two Codebases</h5></header><p>The code-with-accompanied-documentation is somewhat a sub-case of a more general fallacy: the belief that a company can simultaneously maintain two different codebases (say two codebases implementing the same functionality in two different languages), while keeping them both synchronised.</p><p>The Extreme Programming experts have been warning against it, and it also makes sense that it is hard to do given that programmers, by nature, lack the appropriate discipline to keep maintaining two or more codebases at once.</p><p>One possible solution to this problem <a class="link" href="http://www.joelonsoftware.com/articles/FogBugzIII.html">has been illustrated by Fog Creek software</a>. What they did was implement a compiler from a common language, to several target languages. Naturally, this compiler also needs to be maintained and extended, but it is less work and less error-prone than maintaining several different codebases.</p></section></section></main>
</div>
<footer>
<div class="foot_left">
<ul class="bt_nav">
<li><a href="../../../../../">Home</a></li>
<li><a href="../../../../../me/">About</a></li>
<li><a href="../../../../../me/contact-me/">Contact Us</a></li>
<li><a href="../../../../../meta/privacy-policy/">Privacy Policy</a></li>
<li><a href="../../../../../meta/anti-spam-policy/">Anti-Spam
Policy</a></li>
<li><a href="../../../../../meta/FAQ/" title=
"Frequently asked questions list">FAQ</a></li>
<li><a href="../../../../../me/blogs/">RSS/Atom Feeds</a></li>
</ul>
<p>Written, designed, and maintained by Shlomi Fish, <a href=
"mailto:shlomif@shlomifish.org">shlomif@shlomifish.org</a>.</p>
</div>
<a href="../../../../../"><img src="../../../../../images/bk2hp-v2.min.svg" class=
"bk2hp" alt="Back to my Homepage"/></a></footer>
</body>
</html>
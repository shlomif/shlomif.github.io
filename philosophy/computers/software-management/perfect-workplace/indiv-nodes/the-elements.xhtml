<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>The Perfect IT Workplace - Revision 1 - The Elements of a Perfect Workplace</title>
<meta charset="utf-8"/>
<meta name="description" content=
"The Perfect IT Workplace - Revision 1 - The Elements of a Perfect Workplace"/>
<link rel="stylesheet" href="../../../../../faq-indiv.css" media="screen"/>
<link rel="stylesheet" href="../../../../../screenplay.css" media="screen"
title="Normal"/>
<link rel="stylesheet" href="../../../../../print.css" media="print"/>
<link rel="shortcut icon" href="../../../../../favicon.ico" type=
"image/x-icon"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
</head>
<body class="fancy_sects faq_indiv_entry limit_imgs_width screenplay_indiv_entry">
<div class="header" id="header">
<a href="../../../../../"><img src="../../../../../images/evilphish-flipped.png"
alt="EvilPHish site logo"/></a>
<div class="leading_path"><a href="../../../../../">Shlomi Fish’s
Homepage</a> →
<a href="../perfect-it-workplace.xhtml" title="The Perfect IT Workplace - Revision 1">The Perfect IT Workplace - Revision 1</a>

→ <b>The Elements of a Perfect Workplace</b>
</div>
</div>
<div id="faux">
<main class="main faq screenplay">
<section xmlns="http://www.w3.org/1999/xhtml" class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h3 id="the-elements" class="title">The Elements of a Perfect Workplace</h3><h:a class="back_to_faq" href="../perfect-it-workplace.xhtml#the-elements">Node Link</h:a></header><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="hire-the-best-developers" class="title">Hire the Best Developers</h4></header><p><a class="link" href="http://www.joelonsoftware.com/">"Joel on Software"</a> and others have written about the importance of having very good developers. See for example his <a class="link" href="http://www.joelonsoftware.com/articles/GuerrillaInterviewing3.html">"Guerilla Guide to Interviewing"</a>. Bad programmers will create code that's buggy, insecure, hard-to-maintain, etc. The so-called "Medium-level techs" will probably not, but will be heavily under-productive in comparison to star programmers. (And according to <a class="link" href="http://en.wikipedia.org/wiki/Brooks'_law">Brooks' Law</a>, you can't effectively replace one good programmer with many worse ones.)</p><p>As I noted <a class="link" href="http://discuss.joelonsoftware.com/default.asp?joel.3.197867.7">there are many aspects that qualify someone as a good programmer</a>. However, it does not change the fact that hiring a large number of mediocre programmers will never be as effective as hiring one or two good or very good programmers.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="openness" class="title">Openness</h4></header><p>One of the most important trends in the software world recently was towards "openness": open-source, open-content, open-specifications, etc. Most good programmers you can find will find the open source (also known as "Free Software") movement very appealing, and share some of its ideals. I don't propose you should make your software open-source, although, of course, this is often a good business model. However, there are other aspects of openness that you should follow if you want to attract and keep good programmers.</p><p>First of all, don't over protect your code. Make it open-source if possible, give your contractors and consultants (including outsource ones) access to it, and allow your programmers to show parts of it to their online friends to get some advice. You should make as much of it as possible public, under <a class="link" href="http://en.wikipedia.org/wiki/Open_source_license">open source licences</a> to allow it to be used more often, increase its quality, and grow a culture around it. From my experience, working on "shrinkwrap" software that is used by end-users in the wild, and open-source software in particular, is the best way to increase the <a class="link" href="http://www.shlomifish.org/philosophy/computers/high-quality-software/">quality of the software</a> as it requires the most discipline to work on and support.</p><p>Openness does not end at that. Another important aspect is to allow your programmers to tell their friends and family about what they do. Some defence-related companies seem to think keeping everything confidential is a good idea, but that will cause your employees to feel unnecessarily trapped and unable to get help. So if you want to attract the best programmers, make sure they can tell other people of what they do, and what problems they are facing. (I'm not advocating complete transparency, if it's not appropriate, but rather not being overly secretive. )</p><p>Finally, you should avoid vendor lock-in: use standard or documented protocols and specifications, <a class="link" href="http://www.joelonsoftware.com/articles/fog0000000052.html">take Joel Spolsky's advice of letting your users go back</a>, and make sure your users have control of their data and can access it, back it up and access it.</p><p>A good example for this is <a class="link" href="http://flickr.com/">the photo-sharing site Flickr</a>, which has published full APIs for its service, and even allowed these APIs to be used by competing site.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="great-working-conditions" class="title">Great Working Conditions</h4></header><p>You should make sure your employees have great working conditions.</p><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="conditions--kitchen" class="title">Kitchen</h5></header><p>There should be a kitchen with a lot of food, hot and cold beverages, etc.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="conditions--comfortable-offices" class="title">Comfortable Offices</h5></header><p>I don't necessarily agree that your workers should have spacious offices with doors that close, but they should still be comfortable enough. At one of my workplace, I constantly had to move to let other people out of their seats, and this was unbearable. So don't do that.</p><p>In one job that I fondly remember, every employee had their own spacious cube, with a desk to put a computer and a place to put a few chairs. This was much more like it.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="conditions--best-tools" class="title">The Best Tools That Money Can Buy</h5></header><p>This cannot stressed enough. As <a class="link" href="http://www.joelonsoftware.com/articles/fog0000000043.html">Joel Spolsky notes</a> (based on Steve McConnell) in item No. 9 of the Joel Test, you need to "use the best tools that money can buy".</p><p>If you buy old, broken and/or barely functioning hardware, you'll spend a lot of time debugging the problems there, which will waste a lot of precious time. And you may lose a lot of reputation and customers due to down-time. <span class="bold"><strong>Relying on reliable, high-end hardware</strong></span> is a much better idea.</p><p>I've been to two workplaces that gave me an old computer with a 40 GB hard-disk. It wasn't enough at all. At one place, we've reached the limit of this hard-disk due to several large source code checkouts, and as a result needed a bigger hard-disk. And the only hard-disks the lab had were 80 GB ones, which were bought because they were the cheapest (per-disk, not per-capacity). Please, <span class="bold"><strong>buy large enough hard-disks</strong></span>.</p><p>At the same workplace, I was given a computer with a read-only CD-ROM drive. It was not even a DVD reader. I brought a DVD of audio files from home, and could not read it. In this day and age, read/write DVD drives are the standard, and are ultra-cheap.</p><p>Sometimes you'll need <span class="bold"><strong>several computers</strong></span>, or a decent <span class="bold"><strong>virtual machine emulator</strong></span>, to run alternative operating systems on the same machine.</p><p>Make sure your workers have a <span class="bold"><strong>high-quality screen</strong></span>. They need to look at it most of the day, and they want it to look nice. A decent 19" LCD screen nowadays is very cheap nowadays and well worth the added productivity.</p><p>You also need a <a class="link" href="http://better-scm.shlomifish.org/">state-of-the-art version control system</a> , of which there are currently several high-quality open-source alternatives. Some very costly version control systems have a bad reputation for being extreme troublemakers, while the modern open-source alternatives "just work".</p><p>If there's a good commercial software that your employees like to use and can recommend, don't hesitate to buy it. You'll also find <a class="link" href="http://safari.oreilly.com/">O'Reilly Safari</a> Licences to be a good idea so your employees can easily look up and read information in many books online.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="conditions--sane-working-hours" class="title">Sane Working Hours</h5></header><p>Give your employees <a class="link" href="http://www.igda.org/articles/erobinson_crunch.php">sane working hours</a> - 40 hours work-weeks or less. While sometimes asking them to stay late to finish a deadline is acceptable, the so-called "crunch mode" is under-effective and a recipe for disaster.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="conditions--location" class="title">Location, Location, Location</h5></header><p>Find a good place which is close enough for most people to get to. Make sure your programmers can commute to you easily. Even pay for taxi-cabs out of your own expense, or ask other employees to give them a ride, if there isn't good public transportation. The money you spend on the cabs is very small compared to the one you would lose by lost productivity, and by frustrations of travelling.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="conditions--paid-vacation" class="title">A Lot of Paid Vacation</h5></header><p>Give your workers a lot of paid vacation. Humans are not machines - they need rest and relaxation. The 14 annual vacation days mandated by the Israeli government are a joke. You should give them much more than that. Joel Spolsky's Fog Creek software gives 6 weeks of paid vacation, which is much more reasonable.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="conditions--strict-firewalls" class="title">Avoid Over-Strict Firewalls</h5></header><p>Some organisations put their intranets below firewalls that block access to almost all services. It is not uncommon to see only the HTTP and HTTPS ports open for free access.</p><p>However, there are many other Internet services that star programmers need in order to be productive. Among them are:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><a class="link" href="http://en.wikipedia.org/wiki/Internet_Relay_Chat">Internet Relay Chat</a> and other forms of <a class="link" href="http://en.wikipedia.org/wiki/Instant_messaging">Instant Messaging</a>. This allows star programmers to discuss problems and share solutions interactively with their peers, or just to take a break from work and chat.</p></li><li class="listitem"><p><a class="link" href="http://www.openssh.org/">SSH - Secure Shell</a> - allows access to remote computers over the network.</p></li><li class="listitem"><p><a class="link" href="http://en.wikipedia.org/wiki/BitTorrent_(protocol)">BitTorrent</a> - allows downloading some content that is otherwise not available on the Web.</p></li></ol></div><p>And naturally, malware can easily propagate and survive using HTTP and HTTPS alone, and there are ways that clueful workers can overcome such restrictions.</p><p>At one of my workplaces, I was able to chat on the IRC, connect using IM, ssh to everywhere I wanted, etc. without any restriction. It was a liberating feeling and I felt at home there. At a more recent one, I needed to connect to a remote host, and invoke port forwarding in order to talk on the IRC which was annoying and error prone.</p><p>So make sure your firewall is not over-zealous and does not prevent legitimate uses.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="conditions--salary" class="title">About the Salary</h5></header><p>Competitive Salary? Yes, it's important, but not absolutely everything. Great programmers won't work for you for free, but they'll find many other conditions much more tempting than an over-blown salary. See what <a class="link" href="http://www.catb.org/~esr/writings/cathedral-bazaar/homesteading/ar01s19.html">Eric Raymond wrote about it in "Homesteading the Noosphere"</a>, quoting many studies:</p><div class="blockquote"><blockquote class="blockquote"><p>Psychologist Theresa Amabile of Brandeis University, cautiously summarizing the results of a 1984 study of motivation and reward, observed ``It may be that commissioned work will, in general, be less creative than work that is done out of pure interest.''. Amabile goes on to observe that ``The more complex the activity, the more it's hurt by extrinsic reward.'' Interestingly, the studies suggest that flat salaries don't demotivate, but piecework rates and bonuses do.</p><p>Thus, it may be economically smart to give performance bonuses to people who flip burgers or dug ditches, but it's probably smarter to decouple salary from performance in a programming shop and let people choose their own projects (both trends that the open-source world takes to their logical conclusions). Indeed, these results suggest that the only time it is a good idea to reward performance in programming is when the programmer is so motivated that he or she would have worked without the reward!</p></blockquote></div></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="conditions--conclusion" class="title">Conditions: Conclusion</h5></header><p>One final note: you might thing to yourself: <span class="bold"><strong>"how can I afford all that?"</strong></span>. Well, the answer is that the cost of all these advantages is very small in comparison to your general operation. And they will pay themselves much more as time goes by in the happiness, productivity and loyalty of your workers.</p><p>The last thing you want is to lose a competent developer. And all these things will better make sure that he or she will stay with you.</p></section></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="pair-programming" class="title">Pair Programming</h4></header><p>When doing <a class="link" href="http://en.wikipedia.org/wiki/Pair_programming">Pair programming</a>, there are two programmers sitting next to a single computer screen and keyboard, with one of them actually writing the code, and the other one observing and helping. At first glance, it seems like it's a waste of resources: won't they be under-productive? The answer is a "no".</p><p id="pair-programming-and-code-review">First of all, pair programming increases run-time code review, as the "passive" programmer observes what the active programmer writes, gives him advice and answers his question. Code-review is always a good thing. <a href="../perfect-it-workplace.xhtml#ftn.pair-programming-and-code-review" class="footnote"><sup class="footnote">[Code-Review]</sup></a></p><p>Secondly, pair programming causes both programmers to have more discipline, and they are less likely to procrastinate as the active programmer will bore the watching one.</p><p>Pair programming is also more fun, because people feel more comfortable working in pairs than alone.</p><p>Finally, pair programming is more productive, because it was shown that it yields more output than two individual programmers.</p><p>I had had a very good experience working in pairs back when I was an undergraduate student at <a class="link" href="http://www.technion.ac.il/">the Technion</a> and can highly recommend it.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="give-employees-freedom" class="title">Give Your Employees the Freedom to Do What They Want</h4></header><p>If your employee is responsible, he'll care about his job to be productive, even if you don't watch him. If he isn't, then no amount of watching will make him responsible.</p><p>You shouldn't constantly monitor your employees. Instead, give them time to clear their mind and do non-coding-related activities such as:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Play computer games.</p></li><li class="listitem"><p>Browse the web.</p></li><li class="listitem"><p>Watch videos or listen to netcasts.</p></li><li class="listitem"><p>Read articles or books.</p></li><li class="listitem"><p>Work on open-source software or their own personal projects.</p></li><li class="listitem"><p>Chat with their co-workers or online peers.</p></li><li class="listitem"><p>Take walks in the neighbourhood, do sports, go to clubs and other activities.</p></li></ol></div><p>These tasks and others don't interfere with the work much, and actually contribute to productivity. And along with <a class="link" href="../perfect-it-workplace.xhtml#pair-programming" title="Pair Programming">pair programming</a>, you can be more certain your programmers will work. Don't judge your employees by how they spend their time at work - instead judge them by the overall progress they do in the long run.</p><p>Moreover, some tasks that your employees do at their free time, may eventually bring your company publicity and esteem. Part of the reason Joel Spolsky's <a class="link" href="http://www.fogcreek.com/">"Fog Creek Software" company</a> is so well-known is because of the <a class="link" href="http://www.joelonsoftware.com/">Joel on Software</a> blog, which is one of the most-read weblogs about software management. This in turn resulted in a lot of publicity to the Fog Creek products.</p><p id="eric-sink-scrabble">If your employees are productive, you should not really be concerned what they are doing on their work time.<a href="../perfect-it-workplace.xhtml#ftn.eric-sink-scrabble" class="footnote"><sup class="footnote">[EricSink]</sup></a> Google allows its employees work on non-work-related-tasks 20% of the time (while Google still owns the intellectual rights to their creations). I would go a step further by saying you simply should allow your employees to do as much non-work-related leisure as they feel they need to on their working hours. Tell them you expect long-term results, not 100% productivity-of-time.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="job-ads" class="title">Phrase Your Job Ads in a Unique and Smart Way</h4></header><p>"3 Years Experience in Perl - Must", "20 Years Experience in PHP - Advantage", "Team Player", "Independent Thinker". <span class="bold"><strong>Boring</strong></span>.</p><p>Your job ad need to stand out. Take <a class="link" href="http://groups.google.com/group/israelrb/browse_frm/thread/bb11cf1c3ed8e221">this job ad that was posted to the Israeli Ruby mailing list</a> for an excellent example:</p><div class="blockquote"><blockquote class="blockquote"><p>We are looking for a developer who:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Want a full time, salaried position.</p></li><li class="listitem"><p>Want to work in a fun, young workplace.</p></li><li class="listitem"><p>Want to work in an environment that allows them to use (just about) whatever tools they wish to get the job done.</p></li><li class="listitem"><p>Knows and love Ruby.</p></li><li class="listitem"><p>Ideally have experience with PHP and Python.</p></li><li class="listitem"><p>Want to work on large scale Rails/Merb projects that have nothing to do with "the Social Web".</p></li><li class="listitem"><p>Want to drown a puppy every time they hear phrases like "the Social Web".</p></li></ul></div></blockquote></div><p>See? I also want to write sites that are not necessarily "Social Web", and I also got tired of the "Social Web" and its association with Ruby and other similar technologies. So this ad has caught my attention.</p><p id="linux-systems">As <a class="link" href="http://www.joelonsoftware.com/articles/LordPalmerston.html">Joel on Software notes about experience</a>, the reason companies want people with a lot of experience in a certain niche, is because they tend to overcome problems they encounter more easily and so can help themselves and their co-workers with their problem more easily.<a href="../perfect-it-workplace.xhtml#ftn.linux-systems" class="footnote"><sup class="footnote">[Linux-Systems-Programming]</sup></a></p><p>However, as long as you have someone with enough experience, then bright people without a lot of experience can still prove to be useful and very productive. So don't demand too much from them. As of 2008, there aren't enough clueful developers in Israel for all the workplaces (and I think that's also the case in most other places), and you can't afford to be too picky.</p><p>Another tip I can offer to look for employees is to use specialised job boards like the <a class="link" href="http://jobs.joelonsoftware.com/">the Joel on Software job-board</a>, and <a class="link" href="http://jobs.perl.org/">jobs.perl.org</a>, <a class="link" href="http://jobs.thedailywtf.com/1001/browse.aspx">the DailyWTF "Non-WTF" board</a> which highly-qualified and niche people follow. Just make sure to phrase your ad in a non-boring way, as I noted earlier.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="read-software-management-material" class="title">Read a Lot of Software Management Material</h4></header><p>It's impossible to put all the good advice I found regarding software management and software engineering online and offline, in one document. So I argue you as a manager or an employee to read as much different material you can find. There's a lot of good advice out there. Socrates said: "I know that I do not know.", and he was right.</p><p>While it's easy to dismiss other people as "idiots" or what they say as being "stupid", one should realise that even incorrect conclusions or reasoning can bring useful insights, and give some food for thought. Sometimes, I find some useful insights in rehearsed things or short blog entries.</p><p>If you're a manager or team-leader, you should make sure that you're not much more clue-less than your programmers are, but that has often been the case for me and others.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="listen-to-your-devs" class="title">Listen to Your Developers</h4></header><p>Which brings us to this: you obviously cannot get every aspect of software management right at first. Your programmers may eventually become unhappy, and you should make sure they can tell you how they feel, and to take note of what they say. Otherwise, you're risking underproductivity or downright <a class="link" href="http://en.wikipedia.org/wiki/Clinical_depression">clinical depression</a>.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="software-engineering" class="title">Software Engineering Best Practices</h4></header><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="functional-specs" class="title">Functional Specs</h5></header><p>The first advice I can give is to <a class="link" href="http://www.joelonsoftware.com/articles/fog0000000036.html"><span class="bold"><strong>write functional specs</strong></span></a>. In the link, Joel Spolsky explains the motivation and method of writing functional spec. A functional spec describes how the end-user will use and interact with the program. It is not a technical spec which explains how the inner software will work.</p><p>From my experience, functional specs are fun to write, reveal many problems in the initial design, and make you think how the software will work on the inside.</p><p>Here are three examples for functional specs I wrote:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><a class="link" href="http://svn.berlios.de/svnroot/repos/web-cpan/App-Freelancers-Board-Yonathan/trunk/docs/functional-spec/App-Freelancer-Board-Yonathan-functional-spec.txt">Functional Spec for a Freelancers Board</a> (with a Biblical theme).</p></li><li class="listitem"><p><a class="link" href="http://svn.berlios.de/svnroot/repos/web-cpan/CPAN-Module-Classification/trunk/docs/functional-spec-for-CPAN-Classification-Proposal.txt">Functional Spec for a better classification of CPAN Modules</a> (with a theme of FOSS world celebrities).</p></li><li class="listitem"><p><a class="link" href="http://svn.berlios.de/svnroot/repos/winapt/winapt/trunk/docs/design/functional-spec.txt">Functional Spec for a Windows package management system.</a> (featuring characters from <a class="link" href="http://www.ozyandmillie.org/">Ozy and Millie</a>).</p></li></ol></div></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="automated-tests" class="title">Automated Tests</h5></header><p>You should write automated tests such as unit tests, integration tests, system tests, that will run automatically on the code and yield an answer if all of them are successful, or if any of them fail.</p><p>There are many good practices for automated testing such as having daily builds or reaching a 100% test coverage. Here are some resources to get you started:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="link" href="http://qa.perl.org/">The Perl Quality Assurance project</a>, also see their wiki.</p></li><li class="listitem"><p><a class="link" href="http://en.wikipedia.org/wiki/Software_testing">The Wikipedia page about Software Testing.</a></p></li></ul></div><p>Note that having automated tests is not a substitute for having <a class="link" href="http://www.joelonsoftware.com/articles/fog0000000067.html">dedicated software testers</a> (and vice versa). By all means, they are both necessary for any serious operation.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="design-and-planning" class="title">Design and Planning</h5></header><p>Most people agree that designing a software, planning it and thinking about it is a good idea. Extreme Programming suggests to have one design meeting every day. I personally feel that too much design like that is equivalent to very little of it, but still design and planning should be done</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="refactoring" class="title">Refactoring</h5></header><p><a class="link" href="http://www.refactoring.com/">Refactoring</a> is the process of improving the internal quality of the code (from "a big mess" to "squeaky-clean and modular code"), while not changing its external behaviour. This is done for mostly functional and bug-free, but sub-optimally-written, code so it can be better managed.</p><p>"Joel on Software" features two excellent article about the motivation for refactoring: <a class="link" href="http://www.joelonsoftware.com/articles/fog0000000069.html">"Things You Should Never Do, Part I (why rewriting functional code from scratch is a bad idea)"</a>, and <a class="link" href="http://www.joelonsoftware.com/articles/fog0000000348.html">"Rub a dub dub" (how and why to do refactoring).</a>.</p><p>There are many other resources for that online, along with many refactoring patterns.</p><p>There are many types of refactoring: grand refactoring sessions (= what Joel describes), continuous refactoring (refactoring as you go), "just-in-time refactoring" (refactoring enough to achieve a certain task), etc.</p><p>But refactoring is important, makes development faster in the long run (and even in the short-run), and can prevent the code from deteriorating into an ugly, non-functional mess that would be hard to salvage.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="soft-eng-methods-to-avoid" class="title">Software Engineering Methods to Avoid</h5></header><p>There are few software engineering methods that I find pointless, so I'd like to briefly point them out.</p><p>The first is the <span class="bold"><strong>"Huge-design-up-front"</strong></span>, where an "architect" or even the entire team spends a very long time writing an extremely comprehensive and detailed technical document that specifies in detail how the software will work.</p><p>The problem with this approach is that it is a huge waste of time and also it is impossible to design a large project top-down like that. A better way is to involve the entire team in a good design session (a week long at first) while writing some functional specs, diagrams and some other documents, and then to write it incrementally.</p><p id="extract-method">A similar fallacy is the <span class="bold"><strong>"Mountains of documentation fallacy"</strong></span> of having superfluous commenting, Literate programming, etc. The problem with this approach is that the extra documentation is often redundant if the code is well written and factored out <a href="../perfect-it-workplace.xhtml#ftn.extract-method" class="footnote"><sup class="footnote">[Extract-Method]</sup></a></p><p>Some documentation (especially API documentation such as <a class="link" href="http://en.wikipedia.org/wiki/Plain_Old_Documentation">Perl's POD</a> or <a class="link" href="http://www.doxygen.org/">Doxygen</a>) is good, and you shouldn't feel too guilty about writing a comment for an interesting trick, but too much documentation slows things down, and doesn't help with the design process, and eventually may turn out to be misleading or harmful.</p><p>Something else I consider a bad idea is <a class="link" href="http://en.wikipedia.org/wiki/You_Ain't_Gonna_Need_It">Overengineering or YAGNI ("You Ain't Gonna Need It")</a>. The basic idea is not to implement too many features at once, or over-complicate the design of the code, and instead focus on getting the necessary functionality working.</p><p>YAGNI, put aside, I still believe that some forward-planning is good.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="maintaining-two-codebases" class="title">Maintaining Two Codebases</h5></header><p>The code-with-accompanied-documentation is somewhat a sub-case of a more general fallacy: the belief that a company can simultaneously maintain two different codebases (say two codebases implementing the same functionality in two different languages), while keeping them both synchronised.</p><p>The Extreme Programming experts have been warning against it, and it also makes sense that it is hard to do given that programmers, by nature, lack the appropriate discipline to keep maintaining two or more codebases at once.</p><p>One possible solution to this problem <a class="link" href="http://www.joelonsoftware.com/articles/FogBugzIII.html">has been illustrated by Fog Creek software</a>. What they did was implement a compiler from a common language, to several target languages. Naturally, this compiler also needs to be maintained and extended, but it is less work and less error-prone than maintaining several different codebases.</p></section></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="specialisation" class="title">Don't Over-Specialise</h4></header><p>Many workplaces seem to think that it is a good idea to make sure every developer is limited to a certain aspect of the development process, and will specialise exclusively in it. Taken to extreme, however, such a trend is very dangerous.</p><p>Programmers need to have a solid understanding of the entire product stack in their head. Good programmers can also benefit from a change of scenery. And naturally, <a class="link" href="http://en.wikipedia.org/wiki/Code_review">reviewing someone else's code</a>, and criticising it, is also always beneficial.</p><p>Therefore, you should make sure that your workers don't over-specialise. Let them dedicate some time to work on what they find interesting, and let them review and criticise other people's work.</p><p>Once, before I started my undergraduate studies, I worked for a developer of a software-based modem (so-called "Winmodems"). I was impressed from the atmosphere there, and how professional and clueful the managers were. One of the things I liked about the job was that while I was initially hired as a tester, I eventually was appreciated for my eclectic knowledge of different aspects of sound, games, modems, Internet, and other fields. So, I was given more diverse things to do there, involving many aspects of our operation.</p><p>You should follow suit and involve your star developers in as many aspects of your development.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="listen-to-your-customers" class="title">Listen to Your Customers or Users</h4></header><p>Joel on Software gives <a class="link" href="http://www.joelonsoftware.com/articles/customerservice.html">a lot of good advice on having a good customer service</a>. You should listen to what your customers (or users) say. Don't dismiss them. Don't give them annoying canned responses. Open your bug-tracker to the world as a web-service. There are many web-based, and gratis bug-trackers, such as <a class="link" href="http://www.bugzilla.org/">Bugzilla</a>, and you should use one of them for better interaction with your customers.</p><p>As Joel indicates, a bug report, email, or query usually indicates a problem in the software: a bug, a missing feature, or something that's not clear enough. Such problems need to be fixed in the code.</p><p>Furthermore, if one or more of your customers are requesting a feature, and it seems to be important enough, give a priority to implementing it. As a Mercury Interactive (Now part of HP) developer <a class="link" href="http://tech.groups.yahoo.com/group/hackers-il/message/2751">noted</a> usually the features requested by the customers, are the ones that will yield the most newer customers, not-to-mention will allow keeping customers, if they are paying for upgrades or as a "software-as-a-service" model.</p><p>Joel Spolsky <a class="link" href="http://www.inc.com/magazine/20080401/how-hard-could-it-be-fire-and-motion.html?partner=fogcreek">also notes that good customer service is part of the key to a small ISV's success</a>.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="great-poets-steal" class="title">"Good Poets Borrow. Great Poets Steal."</h4></header><p>Originality and "innovation" is not as important as people think it is. It is perfectly OK to create a product in <a class="link" href="http://www.joelonsoftware.com/articles/fog0000000056.html">a niche which has a lot of existing competition</a>, it's OK to build on other people's efforts, and it's OK to "borrow" or "steal" (see the quote at the top) ideas from your users, competitors and friends.</p><p>You're not getting credit for originality - you're getting credit for high-quality products (software, services, support, etc. - whatever you do) and especially for revenue and profits. See <a class="link" href="http://www.joelonsoftware.com/articles/fog0000000074.html">"Converting Capital into Software That Works" for more information</a></p><p>Another common fallacy is that ideas are the hardest part of the production process. However, ideas are very cheap, and creative people have far too many good ideas. It's actually harder to develop the idea into a product, to mass-produce it, and then to mass-distribute it. Edison was not the first to come up with the Electrical Lightbulb, or to develop a working prototype, but he was the one to have put up all the effort in making it so popular and prevalent. Therefore, he is rightly credited as its inventor.</p><p>Similar in software, you can often see competing products displacing more established competition, or sometimes a market where there isn't a clear winner (e.g: <a class="link" href="http://xwinman.org/">window managers and desktop environments for Unix</a>, Bug trackers, text editors, etc.)</p><p id="ideas-at-the-same-time">Even making rounder wheels is a good way to earn a living and to get respect.<a href="../perfect-it-workplace.xhtml#ftn.ideas-at-the-same-time" class="footnote"><sup class="footnote">[Ideas]</sup></a></p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="study-psychology" class="title">Study Psychology</h4></header><p>Your co-workers are people. As such they have thoughts, feelings, emotions, and desires, which guide them and affect them. Learning how people's psychology works, and how to motivate people and help them if they are feeling de-motivated - will help an employer be more effective, and make his employees more productive.</p><p>This is also the case for your customers, users, associates and friends, who you will surely have to interact with , make sure they are happy most of the time, and deal with their problems effectively.</p><p>Here are a few good resources on Psychology:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="link" href="http://www.amazon.com/exec/obidos/ASIN/0380810336/ref=nosim/shlomifishhom-20/">"Feeling Good: The New Mood Therapy"</a> - the best book I've read about Psychology. A self-help book of <a class="link" href="http://en.wikipedia.org/wiki/Cognitive_behavioral_therapy">Cognitive-behavioural therapy</a>, this books explains what causes Clinical depressions, and other negative mood swings, and why people behave the way they do.</p><p>It is a stark anti-thesis to Freudian psychology, which makes little sense and is completely not helpful.</p></li><li class="listitem"><p><a class="link" href="http://www.shlomifish.org/philosophy/philosophy/guide-to-neo-tech/">"The Neo-Tech Discovery"</a> - an off-shoot of Ayn Rand' Objectivism, Neo-Tech is the best idea-system I've encountered yet. Note that it is easy to both dismiss Neo-Tech as a stupid cult, or to hugely misunderstand it at first. So when reading Neo-Tech go over the material (preferably without skipping, but possibly while taking breaks), and then let it sink for a while.</p><p>Note that as of May 2008, the old hyperlinks to the Neo-Tech site lead to redirects or PHP errors. You can still find the old pages on <a class="link" href="http://www.archive.org/">the web archive</a>, and I hope they'll get fixed. In any case, it may be a good idea to order "The Neo-Tech Discovery" book. (It is not available in book stores).</p></li><li class="listitem"><p><a class="link" href="http://www.amazon.com/exec/obidos/ASIN/0465067107/ref=nosim/shlomifishhom-20/">"The Design of Everyday Things"</a> - this book is a must read to everyone doing user-interface design. It explains how frustrating it is to use many everyday objects (and, by inflection, software and software devices), and how to design them right.</p></li><li class="listitem"><p><a class="link" href="http://www.amazon.com/exec/obidos/ASIN/071672328X/ref=nosim/shlomifishhom-20/">"Helplessness: On Depression, Development and Death"</a> - I haven't read this book yet, but it was recommended on <a class="link" href="http://www.joelonsoftware.com/navLinks/fog0000000262.html">the "Joel on Software" book reviews</a>, which I found to be of value. It is also written from the Cognitive-Behavioural Psychology viewpoint.</p></li></ul></div><p>Naturally, becoming a more psychologically-capable person is a process. No one is fully friendly, tactful, helpful, and considerate at all times. But one must always aspire to be more.</p><p>For example, at one of the workplaces I had, whenever I told my boss that I didn't finish what he asked for, but instead found out something else of importance or made some other progress he said "So what you're saying is that you didn't achieve anything.". This is a classical case of the <span class="bold"><strong>"All or Nothing Thinking"</strong></span> cognitive error, which is given in "Feeling Good" as a possible primary cause of depression.</p><p>This attitude caused me to think and feel that nothing I could do, would possibly please him, and that he was demotivating on purpose. This was one of the reasons that caused me to assume a <a class="link" href="http://en.wikipedia.org/wiki/Hypomania">variation of a clinical depression called "Hypomania"</a>, which in turn made me under-productive.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="success-and-failure-stories" class="title">Read Success and Failure Stories</h4></header><p>One of the many quotes featured at the signature of a friend of mine is <span class="quote">&#8220;<span class="quote">Learn from mistakes of others; you won't live long enough to make them all yourself</span>&#8221;</span>. It is important to read success and failure stories of what people did, what mistakes they performed and what are their conclusions.</p><p>I believe we can learn more from the failures of ourselves and others, than we can learn from successes. That's because in a success, almost every aspect was done right, while in a failure one can look back and say where things went wrong.</p><p>You can find many such stories on the Internet, and sometimes you'll hear about them in news sites, blogs, and various forums.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="knowledge-in-the-ether" class="title">Avoiding "Knowledge in the Ether"</h4></header><p>One of the anti-patterns I encountered in previous workplaces and one especially is that of <a class="link" href="http://use.perl.org/~Shlomi+Fish/journal/33013">the "Knowledge in the Ether"</a>. Quoting from my original post:</p><div class="blockquote"><blockquote class="blockquote"><p>One anti-pattern I noted in a previous workplace was what I called "Knowledge in the Ether": most of the instructions for getting the application up and running, and a lot of the collective knowledge were not written down in a collective place. TDDPirate said he was familiar with it and called it the <a class="link" href="http://en.wikipedia.org/wiki/Oral_Torah">"Oral Torah"</a> syndrome.</p><p>The solution for this is simple: set up a wiki for the company, and instruct people to write a note there whenever they need to explain to someone how to do it (or give a link to a previous note), <span class="bold"><strong>instead of</strong></span> guiding him how to do it. While this requires some discipline and getting used to, it can also be done after the fact.</p><p>Obviously the amount of knowledge in people's head and in the Ether can never be completely eliminated. But it should be kept down to a minimum.</p></blockquote></div><p>There was also a comment that said one should write a script to do that. And it's a good idea to keep good README files, comments, etc. and to use a standard building procedure, or prepare distribution-level packages for the software.</p><p>Nevertheless, a workplace should encourage its employees to note down every useful knowledge and procedure. My friend once told me that in his previous workplace they kept a knowledge-base as a group of Microsoft Word documents stored inside Visual SourceSafe. As a result, people felt it was too much bother to update and maintain them. Eventually, he set up an instance of <a class="link" href="http://www.mediawiki.org/">MediaWiki</a> there, which proved to be much more convenient, accessible and quick.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="which-technology" class="title">Choose Your Technology Carefully</h4></header><p>So which technology should you choose? I'm not giving to give a direct answer, and often there are many factors that make one more appropriate in certain cases than others. Joel Spolsky <a class="link" href="http://www.joelonsoftware.com/items/2006/09/01.html">attempted to answer this question</a>, but ended up falling into many common miconceptions and prejudices (while still making a few good points). He was also focusing exclusively on web-development.</p><p>I won't repeat this mistake here, but instead give some general guidelines.</p><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="tech-foss-and-portability" class="title">Is it Open-source and/or Portable?</h5></header><p>One huge advantage to a technology is that it will be open-source and available on several operating systems, including most Unixes and Windows 32-bit, and on many CPU architectures. While, often you'll encounter many platform-specific bugs or libraries or programs that work properly only on certain configurations (which is expected), you should still have the choice of being able to rely on the technology being present.</p><p>For example, Microsoft's <a class="link" href="http://en.wikipedia.org/wiki/Visual_Basic">Visual Basic</a> was a closed-source and Windows 32-bit and x86 specific programming language, which had proven to be very popular. However, Microsoft decided to discontinue it completely, and as a result, many of the applications developed for it can no longer be maintained into the future, and important bugs in Visual Basic will not get fixed.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="tech-expect-unexpected" class="title">Expect some Unexpected Problems</h5></header><p><a class="link" href="http://www.faqs.org/docs/artu/ch16s01.html">Eric Raymond's "Tale of J. Random Newbie"</a> is illustrative of the many problems programmers encounter in highly-proprietary environments. Generally however, even if you're using proven, mature, well-documented and functional technology, you are likely to encounter bugs.</p><p>I like Perl a lot, and have recently found some bugs or even crashes in Perl code, which I've been trying to isolate and report. Perl is otherwise very good and reliable, but advanced users, or even intermediate ones are likely to discover many edge cases.</p><p>You should make sure you have the capability to isolate, report and possibly send a fix to such a technological problem, and get a prompt fix. This often depends on having good support from the technology vendor or developer.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="tech-power" class="title">The Technology's Power</h5></header><p>Various technologies and <a class="link" href="http://www.joelonsoftware.com/articles/Platforms.html">development platforms</a>, vary in their power and cost. As opposed to the possible misconception of "If you want something good, you'll have to pay more.", often cheaper, or even gratis (or open-source) solutions are more powerful (not to mention more reliable and faster) than their more costly counterparts.</p><p>Often, however, the really good solutions will be an overkill. Most experts I've talked with agreed that the <a class="link" href="http://www.oracle.com/database/index.html">Oracle Database</a> is the most powerful on the market and "years ahead of anything else out there". However, most run-of-the-mill web applications won't make use of even a small percentage of its advanced features, enough to justify using it instead of, say, the open-source and gratis <a class="link" href="http://www.postgresql.org/">PostgreSQL</a>.</p><p>For many problem domains, Oracle would make the most sense, but it's still not very useful in the general case.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="tech-habits" class="title">Habits</h5></header><p>It makes sense to <a class="link" href="http://www.joelonsoftware.com/articles/LordPalmerston.html">choose a technology which you know very well</a>, so you can overcome problems more quickly. However, smart programmers can learn different technologies very quickly. As Spolsky <a class="link" href="http://www.joelonsoftware.com/articles/ThePerilsofJavaSchools.html">notes</a>:</p><div class="blockquote"><blockquote class="blockquote"><p>The recruiters-who-use-grep, by the way, are ridiculed here, and for good reason. I have never met anyone who can do Scheme, Haskell, and C pointers who can't pick up Java in two days, and create better Java code than people with five years of experience in Java, but try explaining that to the average HR drone.</p></blockquote></div><p>If you expect that you <a class="link" href="../perfect-it-workplace.xhtml#hire-the-best-developers" title="Hire the Best Developers">will hire the best developers, as I pointed earlier</a>, then they should probably be able to pick up something new fairly quickly. If, on the other hand, you're going to hire bad programmers, then you're likely to be screwed - even if they have extensive experience with their native technology.</p><p>So you should choose the best technology - not the one for which you expect to find the most "experts".</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="tech-reliability-and-reputation" class="title">Reliability and Reputation</h5></header><p>Often a technology will get a bad reputation as being "quirky", "hard-to-get-right", "buggy", "unreliable", etc. This for example, has been the case <a class="link" href="http://www.shlomifish.org/open-source/anti/mysql/">against MySQL</a>, <a class="link" href="http://www.google.com/search?q=php%20sucks">against PHP</a>, against Sendmail, and against other technologies. From my experience, such common criticisms often have a lot of substance for them and should be evaluated, especially if there are equally affordable technologies, but such of a better reputation.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h5 id="tech-case-study" class="title">Case Study</h5></header><p>I once been to a job interview in downtown Tel-Aviv, which went very well. Then I received a phone call from them that they want me to come and install Fedora Linux on the computer. I did that, and next thing I knew, I was given other tasks.</p><p>I was instructed to write a mail-processing framework in PHP. Now since I know and love Perl, I know there are many fine modules for doing that on <a class="link" href="http://sial.org/howto/perl/life-with-cpan/">CPAN (= The Comprehensive Perl Archive Network)</a>, but there was little of substantial quality for PHP. At a certain time I needed to register at a site, to download the latest version of a PHP library, that was free software, because the download required authentication. There didn't seem to be anything better.</p><p>I was told that they would prefer to write everything in PHP, because they expected to hire only PHP programmers, possibly without any Perl experience.</p><p>That wasn't all. They also decided against using <a class="link" href="http://www.postfix.org/">Postfix</a>, which is a modern, high-performance and open-source SMTP server, and instead preferred the old Sendmail SMTP server which has a far worse reputation, and an arcane configuration system.</p><p>Furthermore, they also decided to use MySQL instead of PostgreSQL, and we ran into a PHP misbehaviour (which was fixable given a lot of PHP know-how) that made us have to restart the connection to the server after every request. Both MySQL and Sendmail were chosen from political reasons.</p><p>With my PHP code barely working and prune to many errors, I decided to quit after about a month, out of being appalled by the bad code craftsmanship I could do there. Make sure you don't repeat such a mistake.</p></section></section><div class="footnotes"><br/><hr class="footnote-hr"/><div id="ftn.pair-programming-and-code-review" class="footnote"><p><a href="../perfect-it-workplace.xhtml#pair-programming-and-code-review" class="para"><sup class="para">[Code-Review] </sup></a>Pair programming is still not a substitute for code reviews by people who didn't directly write the code. It was noted at a blog entry I recall reading somewhere but can no longer find. <span class="bold"><strong>TODO: Write more.</strong></span></p></div><div id="ftn.eric-sink-scrabble" class="footnote"><p><a href="../perfect-it-workplace.xhtml#eric-sink-scrabble" class="para"><sup class="para">[EricSink] </sup></a>Eric Sink wrote <a class="link" href="http://www.ericsink.com/entries/scrabble_1994.html">a wonderful entry about the tolerance of his former boss</a> on his weblog. (Here's <a class="link" href="http://www.ericsink.com/entries/ethics.html">an update</a>.)</p></div><div id="ftn.linux-systems" class="footnote"><p><a href="../perfect-it-workplace.xhtml#linux-systems" class="para"><sup class="para">[Linux-Systems-Programming] </sup></a>For example, I have a lot of experience working on Linux and developing for it, with Perl and doing mostly Algorithms and Text Processing in C. Recently, however I got a job as a developer for a Linux Server-side C/C++ application. (dealing with sockets, processes, threads, Unicode and other such advanced problems). While I made a lot of progress, I noticed that I often got stuck on many problems, for which I had no idea how to easily resolve. In this case, my co-worker who had more experience than me in this area, could often help me more.</p></div><div id="ftn.extract-method" class="footnote"><p><a href="../perfect-it-workplace.xhtml#extract-method" class="para"><sup class="para">[Extract-Method] </sup></a>A good example is that instead of having the following pseudo-code:</p><pre class="programlisting">

function create_employee(params)
{
    my emp = emp.new();

    emp.set_birth_year(params[year]);

    emp.set_experience_years(param[exp_amount]);

    emp.set_education(params[education]);

    ### Calculate the salary:
    emp.set_salary(emp.calc_education_factor(emp.get_education()) * emp.set_experience_years());

    ### More stuff snipped.

    return emp;
}

                        </pre><p>Then it would be a good idea to extract the complex <code class="literal">emp.set_salary()</code> call to a simple <code class="literal">emp.calculate_salary()</code> method. This <a class="link" href="http://c2.com/cgi/wiki?ExtractMethod">method extraction</a> will make the intention of the code self-documenting (as the method will have a meaningful name) and much more robust for future changes than adding a comment.</p><p>And this is just a small example.</p></div><div id="ftn.ideas-at-the-same-time" class="footnote"><p><a href="../perfect-it-workplace.xhtml#ideas-at-the-same-time" class="para"><sup class="para">[Ideas] </sup></a>I once saw a quote that said:</p><div class="blockquote"><blockquote class="blockquote"><p>If you have the same ideas two weeks before everybody else - you'll be considered a visionary. If you have them two years before everybody else, you'll be considered a lunatic.</p></blockquote></div><p>This illustrates that as technology progresses, people tend to get the same ideas at roughly the same time, when they are mature and the natural logical step forward. It's unlikely you can avoid it.</p></div></div></section></main>
</div>
<footer>
<div class="foot_left">
<ul class="bt_nav">
<li><a href="../../../../../">Home</a></li>
<li><a href="../../../../../me/">About</a></li>
<li><a href="../../../../../me/contact-me/">Contact Us</a></li>
<li><a href="../../../../../meta/privacy-policy/">Privacy Policy</a></li>
<li><a href="../../../../../meta/anti-spam-policy/">Anti-Spam
Policy</a></li>
<li><a href="../../../../../meta/FAQ/" title=
"Frequently asked questions list">FAQ</a></li>
<li><a href="../../../../../me/blogs/">RSS/Atom Feeds</a></li>
</ul>
<p>Written, designed, and maintained by Shlomi Fish, <a href=
"mailto:shlomif@shlomifish.org">shlomif@shlomifish.org</a>.</p>
</div>
<a href="../../../../../"><img src="../../../../../images/bk2hp-v2.min.svg" class=
"bk2hp" alt="Back to my Homepage"/></a></footer>
</body>
</html>
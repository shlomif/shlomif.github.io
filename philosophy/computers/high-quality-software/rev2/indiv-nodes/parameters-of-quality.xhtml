<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>What Makes Software High-Quality? (Revision 2) - Parameters of Quality</title>
<meta charset="utf-8"/>
<meta name="description" content=
"What Makes Software High-Quality? (Revision 2) - Parameters of Quality"/>
<link rel="stylesheet" href="../../../../../faq-indiv.css" media="screen"/>
<link rel="stylesheet" href="../../../../../screenplay.css" media="screen"
title="Normal"/>
<link rel="stylesheet" href="../../../../../print.css" media="print"/>
<link rel="shortcut icon" href="../../../../../favicon.ico" type=
"image/x-icon"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
</head>
<body class="fancy_sects faq_indiv_entry limit_imgs_width screenplay_indiv_entry">
<div class="header" id="header">
<a href="../../../../../"><img src="../../../../../images/evilphish-flipped.png"
alt="EvilPHish site logo"/></a>
<div class="leading_path"><a href="../../../../../">Shlomi Fish’s
Homepage</a> →
<a href="../" title="What Makes Software High-Quality? (Revision 2)">What Makes Software High-Quality? (Revision 2)</a>

→ <b>Parameters of Quality</b>
</div>
</div>
<div id="faux">
<main class="main faq screenplay">
<section xmlns="http://www.w3.org/1999/xhtml" class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h3 id="parameters-of-quality" class="title">Parameters of Quality</h3><h:a class="back_to_faq" href="../#parameters-of-quality">Node Link</h:a></header><p id="good_code">This section will cover the parameters that make software high quality. However, it will not cover the means to make it so. These include such non-essential things as having good, modular code <a href="../#ftn.good_code" class="footnote"><sup class="footnote">[having_good_code]</sup></a> good marketing, or having good automated tests. These things are definitely important, but will be covered only later, and a lot of popular, high-quality software lacks some of them, while its competition may do better in this respect.</p><p id="parameters-not-foss">One note that is in order is that these are <span class="bold"><strong>many parameters in a generic &#8220;weight function&#8221;</strong></span>, and not a list of requirements which must all be satisfied. <a href="../#ftn.parameters-not-foss" class="footnote"><sup class="footnote">[Licence]</sup></a></p><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="software_is_available" class="title">The Program is Available for Downloading or Buying</h4></header><p>That may seem like a silly thing to say, but you&#8217;ll be surprised how many times people get it wrong. How many times have you seen web-sites of software that claim that the new version of the program (or even the first) is currently under work, will change the world, but is not available yet? How many times have you heard of web-sites that are not live yet, and refuse to tell people exactly what they are about?</p><p>Alternatively, in the case of <a class="link" href="http://en.wikipedia.org/wiki/Coverity">the &#8220;Stanford checker&#8221;</a>, which is a sophisticated tool for static code analysis, it is not available for download, but instead is a service provided by its parent company.</p><p>A program should be available in the wild somehow (for downloading or at least buying) so people can use it, play with it, become impressed or unimpressed, report bugs, and ask for new features. Otherwise it&#8217;s just in-house software or at most a service, that is not adequate for most needs.</p><p>In the &#8220;Cathedral and the Bazaar&#8221;, Eric Raymond recommends <a class="link" href="http://www.catb.org/~esr/writings/cathedral-bazaar/cathedral-bazaar/ar01s04.html">to &#8220;release early and release often&#8221;</a>. Make frequent, incremental releases, so your project won&#8217;t stagnate. If you take your project and work on it yourself for too long, people will give up.</p><p>If you have a new idea for a program, make sure you implement some basic but adequate functionality, and then release it so people can play with it, and learn about it. Most successful open-source projects, that have been open-source since their inception, have started this way: the Linux kernel, gcc, vim, perl, CPython. If you look at the earliest versions of all of them, you&#8217;ll find that they were very limited if not downright hideous, but now they are often among the best of breed.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="version_number_indicated" class="title">The Version Number is Clearly Indicated</h4></header><p>Which version of your software are you using? How can you tell? It&#8217;s not unusual to come to a page where the link to the archive does not contain a version number, nor is it clearly indicated anywhere. What happens if this number was bumped to indicate a bug fix. How do you indicate it then?</p><p>A good software always indicates its version number in the archive file name, the opening directory file name, has a <code class="literal">--version</code> command-line flag, and the version mentioned in the about dialogue if there is one.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="source_is_available" class="title">The Source is Available, Preferably under a Usable Licence</h4></header><p id="ideology">Public availability of the source is a great advantage for a program to have. Many people will usually not take a look at it otherwise, for many reasons, some ideological but some also practical. <a href="../#ftn.ideology" class="footnote"><sup class="footnote">[Ideology]</sup></a> Without the source, and without it being under a proper licence, the software will not become part of most distributions of Linux, the BSD operating systems, etc.</p><p>If you just say that your software &#8220;is copyright by John Doe. All Rights Reserved&#8221;, then it may arguably induce an inability to study its internals (including to fix bugs or add features) without being restricted by a non-compete clause, or even that its use or re-distribution is restricted. Some software ship with extremely long, complicated (and often not entirely enforceable) End-User-Licence-Agreements (EULAs) that no-one reads or cares to understand.</p><p id="public-domain-source">As a result, many people will find a program with a licence that is not 100% <a class="link" href="http://www.gnu.org/philosophy/free-sw.html">Free and Open Source Software</a> - unacceptable. To be truly useful the application also needs be <a class="link" href="http://www.dwheeler.com/essays/gpl-compatible.html">GPL compatible</a>, and naturally usable public-domain licences such as the modified BSD licence, the MIT X11 licence, or even pure Public Domain source code<a href="../#ftn.public-domain-source" class="footnote"><sup class="footnote">[public-domain]</sup></a>, are even better for their ability to be sub-licensed and re-used. This is while licenses that allow incorporation but not sub-licensing, like the Lesser General Public License (LGPL) are somewhere in between.</p><p>While some programs on Linux have become popular despite being under non-optimal licences, many Linux distributions pride themselves that the core system consists of &#8220;100% free software&#8221;. Most software that became non-open-source, was eventually forked or got into disuse, or else suffered from a lot of bad publicity.</p><p>As a result, a high-quality software has a licence that is the most usable in the context of its common use cases. These licences are doubly-important for freely-distributed UNIX software.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="just_works" class="title">It &#8220;Just Works&#8221;</h4></header><p>This is a meta-parameter for quality. When people say that something &#8220;just works&#8221;, they mean that you don&#8217;t have to be concerned about getting it up and running, not spend too much time to learn it, not worry about it destroying data, or have to wonder how to troubleshoot problems with it.</p><p>A program that just works is the holy grail of high-quality software. In practice this means several things:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p id="no_showstopping_bugs">A &#8220;just works&#8221; software also doesn&#8217;t have <span class="bold"><strong>any show-stopping bugs</strong></span>. While it may still have some bugs, it should mostly function correctly.</p></li><li class="listitem"><p>It has most of the <span class="bold"><strong>features people want</strong></span> and does not lack essential ones. For example, GNU Arch, an old and now mostly unused version control program, did not work on Windows 32-bit, while Subversion, a different and popular alternative, has a native port. Moreover, Mercurial, a different alternative, cannot keep empty directories (or trees of directories not containing files) in the repository. This may make both Mercurial and GNU Arch a no-starter for many uses.</p><p><a class="link" href="http://www.tendra.org/">Tendra</a> is the most prominent alternative C and C++ compiler to GCC, but it&#8217;s hardly as advanced as GCC is, does not have all of GCC&#8217;s features and extensions, and is not usable as a replacement for GCC for most needs. As such, it is hardly ever used.</p></li><li class="listitem"><p id="good_usability">A &#8220;just works&#8221; software also has <span class="bold"><strong>good usability</strong></span>. What it means is that it behaves like people expect it to. The Emacs-based editors, which are an alternative to Vim, do not invoke the menus upon pressing &#8220;Alt+F&#8221;, &#8220;Alt+E&#8221;, etc. which is the Windows convention to them.</p><p>Furthermore, when putting a single-line prompt, the prompt cannot be dismissed with either Ctrl+C or ESC, while in Vim, both keys dismiss the prompt. The key combination to dismiss it is not written anywhere on the screen and I won&#8217;t tell you what it is. According to <a class="link" href="http://www.joelonsoftware.com/uibook/chapters/fog0000000057.html">User Interface Design for Programmers</a>, <span class="quote">&#8220;<span class="quote">A user-interface is well-designed when the program behaves exactly how the user thought it would</span>&#8221;</span>.</p><p>While some people may be led to believe this is not applicable to terminal applications, TTY applications, command line applications, or even Application Programming Interfaces (APIs) - it still holds there. One thing that made me like gvim (the Graphical front-end to vim) was that it could be configured to behave much like a Windows editor. I gradually learnt more and more vim paradigms, but found the intuitive usability a great advantage. But I could never quite get used to Emacs.</p></li></ol></div></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="homepage" class="title">The Program has a Homepage</h4></header><p>Most software applications and libraries of high-quality have a homepage which introduces them, has download information, gives links, and provides a starting point to receive more information. And no - a <code class="literal">/project/myprogram/</code> page on <a class="link" href="http://sourceforge.net/">Source Forge</a> or a different software hub - is much more sub-optimal than that, and leaves a bad impression.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="easy_to_compile_and_install" class="title">The Program is Easy to Compile, Deploy and Install</h4></header><p>A high-quality program is easy to compile, deploy and install. It builds out of the box with minimal hassles. There are several common standard building procedures for such software:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>The common standard building procedure using the <a class="link" href="http://sourceware.org/autobook/">GNU Autotools</a> is <code class="literal">./configure --prefix=$PREFIX ; make ; make install</code>.</p></li><li class="listitem"><p>There are now <a class="link" href="http://www.shlomifish.org/open-source/resources/software-tools/">some more modern alternatives to the GNU Autotools</a>, which may also prove useful.</p></li><li class="listitem"><p><a class="link" href="http://www.cpan.org/">CPAN</a> Perl distributions have a similar <code class="literal">perl Makefile.PL</code> procedure or more recently also one using <code class="literal">perl Build.PL</code> which tends to be less quirky (see <a class="link" href="http://cpan.uwinnipeg.ca/dist/Module-Build">Module-Build</a> ).</p><p>Generally, one usually installs them using the CPAN.pm or CPANPLUS.pm interfaces to CPAN, or preferably using a wrapper that converts every CPAN distribution to a native (or otherwise easy to remove) native system package.</p></li><li class="listitem"><p><a class="link" href="http://www.python.org/">Python</a> packages have the standard <code class="literal">setup.py</code> procedure which can also generate Linux RPMs and other native packages.</p></li><li class="listitem"><p>There are similar building procedures for most other technologies out there.</p></li></ol></div><p>However, it&#8217;s not uncommon to find a program that fails to build even on GNU/Linux on an x86 computer, which is the most common platform for development. Or the case of <a class="link" href="http://www.shlomifish.org/open-source/anti/qmail/">the qmail email server</a>, which has a long and quirky build process. It reportedly fails to compile on modern Linuxes, and someone I know who tried to build it said that it did not work after following all the steps.</p><p>One thing that detracts from a piece of software being high-quality is a large amount of dependencies.</p><p>If we take <a class="link" href="http://plagger.org/">Plagger</a>, a web-feed mix-and-match framework in Perl (not unlike <a class="link" href="http://pipes.yahoo.com/">Yahoo Pipes</a>, but predates it), then its <a class="link" href="http://search.cpan.org/dist/Plagger/">Plagger distribution on CPAN</a> contains all of its plug-ins inside, and as a result requires &#8220;half of CPAN&#8221; including such obscure modules, as those for handling Chinese and Japanese dates.</p><p>Popular programs like GCC, perl 5, Vim, Subversion and Emacs have very few dependencies and they are normally included in the package, if necessary to build the system. They are all written in very portable C and POSIX and have been successfully deployed on all modern UNIX-flavours, on Microsoft Windows and on many other more obscure systems.</p><p>While reducing the number of dependencies often means re-inventing wheels, it still increases the quality of your software. I&#8217;m not saying a program cannot be high-quality if it has a large amount of dependencies, but it&#8217;s still a good idea to keep it to a minimum.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="has_packages" class="title">The Program Has Packages for Most Common Distributions</h4></header><p>A good program has packages for most common distributions, or such packages can be easily prepared.</p><p>Lack of such packages will require installing it from source, using generic binary packages, or other workarounds that are harder than a simple command to install the package from the package manager, and may prevent it from being maintained into the future.</p><p>A good example for how this can become wrong is the <a class="link" href="http://www.shlomifish.org/open-source/anti/qmail/">qmail SMTP server</a>, before it became public-domain. The qmail copyright terms prevented distributing modified sources, or binary packages. As a result, the distributions that supported it packaged it as a source package, with an irregular build-process. Since the qmail package had its own unconventional idea of directory structure, some of the distributions had to extensively patch it. This in turn prevented more mainstream patches from being applied correctly to correct the many limitations that qmail had, or accumulated over the years due to its lack of maintenance.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="documentation" class="title">The Program Has Good, Extensive and Usable Documentation</h4></header><p>If your GUI program is simple and well-designed, then you normally don&#8217;t need good documentation. However, a command line program, a library, etc. does need one, or else the user won&#8217;t know what to do.</p><p>There are many types of documentation: the <a class="link" href="http://freshmeat.net/articles/view/519/">--help flag</a>, the man page, the README/USAGE/INSTALL files, full-fledged in-depth guides, documents about the philosophy, wikis, etc. If the program is well-designed, then the user should be able to get up and running quickly. An exception to this are various highly specialised programs, such as 3-D graphics programs, or CAD programs, that require some extensive learning.</p><p>If we take Subversion as an example, then it has a <a class="link" href="http://svnbook.red-bean.com/">full Book online</a>, several tutorials, an <code class="literal">svn help</code> command which provides help to all the other commands, and a lot of help can be found using a Google search. GNU Arch, on the other hand, only had one wordy tutorial, that I didn&#8217;t want to read. Most of the other tutorials people wrote, became misleading or non-functional as the program broke backwards compatibility.</p><p>Vim has an excellent internal documentation system. It&#8217;s the first thing you are directed see when invoking it. It has a comprehensive tutorial, a full manual, and the ability to search for many keywords, with a lot of redundancy. As a result, one can easily become better and better with vim or gvim, albeit many people can happily use it with only the bare essentials.</p><p>Emacs&#8217; help on the other hand is confusing, dis-organised, lacking in explanation and idiosyncratic. It doesn&#8217;t get invoked when pressing &#8220;F1&#8221;, is not directed to when the program starts, and most people cannot make heads nor tails of it. There is a short Emacs tutorial, but it isn&#8217;t as extensive as Vim&#8217;s. Nor does it explain how to configure Emacs to behave in a better way than its default, in which it behaves completely differently to what people who are used to Windows-like conventions or vim-like conventions expect.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="portability" class="title">Portability</h4></header><p>It is tempting to believe that by writing a program for one platform, you can gain most of your market-share. However, people are using many platforms on many different CPU architectures: Windows 32-bit/64-bit on Intel machines, Itanium, or x86-64; Linux on a multitude of platforms; BSD systems (NetBSD, FreeBSD, OpenBSD and others) on many architectures as well; Mac OS X; Sun Solaris (now also OpenSolaris), and more obscure (but still popular) Unix-clones like AIX, HP-UX, IRIX, SCO UNIX, Tru64 (formerly Digital Unix), etc. And to say nothing of more exotic, non-UNIX, non-Microsoft operating systems like Novell Netware, Digital Corp.s&#8217;s VMS or OpenVMS, IBM&#8217;s VM/CMS or OS/390 (MVS), BeOS, AmigaOS, Mac OS 9 or earlier, PalmOS, VxWorks, etc. etc.</p><p id="non-vax-archs">As a general rule, the only thing that runs on top of all of these systems (in the modern &#8220;All the world is a VAX.&#8221; world) is a C-based program or something that is C-hosted. <a href="../#ftn.non-vax-archs" class="footnote"><sup class="footnote">[non-vax-like]</sup></a>Most good programs are portable to at least Windows and most UNIXes and potentially portable to other platforms.</p><p>For example, Subversion has made it a high priority to work properly on Windows. On the other hand many of its early alternatives, especially GNU Arch, could not work there due to their architectures. As a result, many mixed shops, Windows-only shops, or companies where some developers wanted to use Windows as their desktop OS, could not use Arch. So Arch has seen a very small penetration.</p><p>The bootstrapping C compiler of gcc for example, is written in very portable <a class="link" href="http://en.wikipedia.org/wiki/C_(programming_language)#K.26R_C">K&amp;R C</a>, so it can be compiled by any C compiler. Later on, this compiler can be used to compile most of the rest of the GCC compilers.</p><p>Compare that to many compilers for other languages that are written in the same language. For example, <a class="link" href="http://www.haskell.org/ghc/">GHC - The Glasgow Haskell Compiler</a> is written in itself, and requires a relatively recent version of itself to compile itself. So you need to bootstrap several intermediate compilers to build it.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="security" class="title">Security</h4></header><p>A high-quality program is secure. It has a relatively small number of security issues, and bugs are fixed there as soon as possible.</p><p>Some people believe that security is the most important aspect of software, but it&#8217;s only one factor that affects its quality. For example, once I was talking with a certain UNIX expert, and he argued that the Win32 <a class="link" href="http://msdn2.microsoft.com/en-us/library/ms682425.aspx">CreateProcess() system call</a> was superior to the UNIX combination of <a class="link" href="http://en.wikipedia.org/wiki/Fork-exec">Fork() and Exec()</a>, just because it made some bugs harder to code. However, some multitasking paradigms are not possible, without the fork() system call, which is not present in the Win32 API at all, and needs to be emulated (at a high run-time cost) or replaced with thread-based multitasking, which is not identical. Finally, it is still possible to get fork()+exec() right, and there&#8217;s a spawn() abstraction on many modern UNIXes.</p><p>While I don&#8217;t mean you shouldn&#8217;t pay attention to security, or keep good security practices in mind when coding, I&#8217;m saying that it shouldn&#8217;t slow down the process by much, or prevent too many exciting features from being added, or cause the development to stagnate.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="backwards_compatiblity" class="title">Backwards Compatibility</h4></header><p>A high-quality program maintains as much <a class="link" href="http://en.wikipedia.org/wiki/Backward_compatibility">backward compatibility</a> with its older versions as possible. Some backward compatibility, like relying on bugs or other misbehaviours (&#8220;bug-to-bug compatibility&#8221;), is probably too extreme to consider. But users would like to upgrade the software and expect all of their programs to just continue to work.</p><p>A bad example for software that does not maintain backwards compatibility is <a class="link" href="http://www.php.net/">PHP</a>, where every primary digit breaks the compatibility with the older one: PHP 4 was not compatible with PHP 3 and PHP 5 was not compatible with PHP 4. Furthermore, sometimes existing user-land code was broken in minor-digit releases. As such, maintaining PHP code into the future is a very costly process, especially if you want it to work with a range of versions.</p><p>On the other hand, the perl5 developers have been maintaining backwards compatibility between 5.000, 5.001, 5.002 up to 5.6.x, 5.8.x and now 5.10.x. Therefore, one can normally expect older scripts to just work. perl5 can also run a lot of Perl 4 code and below, and Perl 4 code can be ported to modern versions of perl5 with relative ease. While sometimes scripts, programs or modules were broken (due to lack of &#8220;bug-to-bug compatibility&#8221;), or became slower, upgrading to a new version of Perl is normally straightforward.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="good_ways_to_provide_support" class="title">Good Ways to Provide Support</h4></header><p>A piece of high-quality software has good ways for its users to receive support. Some examples for ways to do that are:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>A Mailing List.</p></li><li class="listitem"><p><a class="link" href="http://en.wikipedia.org/wiki/Internet_Relay_Chat">IRC (Internet Relay Chats)</a> Channels.</p></li><li class="listitem"><p>An email address for questions.</p></li><li class="listitem"><p>Web Forums.</p></li><li class="listitem"><p>Wikis.</p></li></ol></div><p>Without good ways to receive support, users will be unnecessarily frustrated when they encounter a problem, which cannot be answered by the documentation. Refer to <a class="link" href="http://www.joelonsoftware.com/articles/customerservice.html">Joel Spolsky&#8217;s &#8220;Seven Steps to Remarkable Customer Service&#8221;</a> for more information on how to give good support.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="speed-and-good-performance" class="title">Speed and High Performance</h4></header><p>The reason I mentioned this quality parameter so late is because it was what Mr. Campbell stressed in his argument about &#8220;Industrial Strength&#8221; Freecell solvers. So I wanted to show that there are other important parameters beside it. However, raw performance is important, too.</p><p>If a program is too slow, or generates sub-optimal results, most people will be reluctant to use it and find using it daunting. They will either give up waiting for it to finish, or get distracted. If the output results of the program are too sub-optimal (assuming there&#8217;s a scale to their optimality), then they will probably look for different alternatives.</p><p>As a result, it is important that your software will run quickly, and will yield good results. There are many ways to make code write faster, and covering them here is out of the scope of this article.</p><p>A good example for how such optimisations can make such a huge difference are the <a class="link" href="http://blog.pavlov.net/2008/03/11/firefox-3-memory-usage/">memory optimisations done to Firefox between Firefox 2 and Firefox 3</a>, which greatly improved its performance, memory consumption, and reduced the number of memory leaks. It should be noted that often, reducing memory consumption can yield better performance because of a smaller number of cache misses, process memory swapping, and other such factors.</p><p>There are several related aspects of performance, that also affect the general quality and usability of a program. One of them is responsiveness, which is often manifested when people complain that the program is &#8220;sluggish&#8221;. Java programs are especially notorious for being such, for some reason, while programs written in <a class="link" href="http://www.perl.org/">Perl</a> and <a class="link" href="http://www.python.org/">Python</a> are more responsive and feel snappy, despite the fact that their backends are generally slower than the Java virtual machine.</p><p>A tangential aspect is that of startup time. Many programs require or have required a long time to start, which also makes using them frustrating, even if they are later responsive and quick.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="aesthetics" class="title">Aesthetics</h4></header><p>A good program (or web site) or other resource is aesthetically pleasing. Aesthetics in this context, does not necessarily mean very &#8220;artsy&#8221; or having a breath-taking style. But we may have run into software (usually one for internal use or one of those very costly, bad-quality, niche, software) that seemed very ugly and badly designed, with a horrible user-interface, etc.</p><p>Different types of applications, and those running on different platforms, have different conventions for what is considered aesthetic. In <a class="link" href="http://catb.org/~esr/writings/taoup/">The Art of UNIX Programming</a>, Eric Raymond <a class="link" href="http://catb.org/~esr/writings/taoup/html/ch11s09.html">makes the case for the &#8220;Silence is Golden&#8221; principle of designing UNIX command-line interfaces</a>. Basically, a command line program should output as little as possible. Now observe the behaviour of aptitude (a unified interface for package management) on Ubuntu Gutsy Gibbon, when trying to install a non-existing package name:</p><pre class="programlisting">

root@shlomif-desktop:/home/shlomif# aptitude install this-does-not-exist
Reading package lists... Done
Building dependency tree
Reading state information... Done
Reading extended state information
Initializing package states... Done
Building tag database... Done
Couldn&#8217;t find any package whose name or description matched "this-does-not-exist"
The following packages have been kept back:
  firefox firefox-gnome-support
0 packages upgraded, 0 newly installed, 0 to remove and 2 not upgraded.
Need to get 0B of archives. After unpacking 0B will be used.
Reading package lists... Done
Building dependency tree
Reading state information... Done
Reading extended state information
Initializing package states... Done
Building tag database... Done

        </pre><p>15 lines of output, and only one of them in the middle is the informative one. Why is all this information a concern of mine, especially given the fact that they are all given in the same monotonous default colour.</p><p>On the other hand, here&#8217;s what urpmi (a similar package management interface for Mandriva) says on Mandriva Cooker:</p><pre class="programlisting">

[root@telaviv1 ~]# urpmi this-does-not-exist
No package named this-does-not-exist
[root@telaviv1 ~]#

        </pre><p>Exactly one line and it&#8217;s informative. While aptitude certainly has its merits, its verbosity still makes it much more painful to use than urpmi, when I have to work on Ubuntu.</p><p>Back to more visual aesthetics, one of the reasons that made me want to use Linux more than Windows 95&#8217; or 98&#8217; was the fact that its desktops were truly themable and could be made to look much better without effort. If I got tired of the same look, I could easily switch. While Windows XP shipped with a more attractive theme, and also had some proprietary and non-gratis theming software, Linux supplied all of that out-of-the-box and with a more attractive theme. The <a class="link" href="http://youtube.com/watch?v=xC5uEe5OzNQ">effects supplied by the Linux 3-D desktops</a>, which have put the 9-milliard Dollar effects of Vista to shame, have convinced some people to install Linux on their computer after seeing them.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="quality-parameters-conclusion" class="title">Conclusion</h4></header><p>There are probably several parameters for software quality that I&#8217;m missing. However, the point is that one should evaluate the general quality of the software based on many parameters and not exclusively &#8220;security&#8221; or &#8220;speed&#8221; or whatever.</p><p id="software-only-on-linux">For example, many proponents of BSD operating systems claim that the various BSDs are superior to Linux because they are more secure, or because they are (supposedly) faster or are easier to manage, because their licence is less problematic than the GPL, etc. However, they forget that Linux has some advantages like being more popular (and so one can get support more easily), or like the fact that its kernel supports much more hardware, or that it has better vendor acceptance, and because more software is guaranteed to run with less problems on Linux than on the BSDs. <a href="../#ftn.software-only-on-linux" class="footnote"><sup class="footnote">[linux-bsd-soft]</sup></a></p><p>I&#8217;m not saying the BSDs are completely inferior to Linux, just that Linux still has some cultural and technical advantages. Quality in software is not a linear metric, because it is affected by many parameters. If you&#8217;re a software developer, you should aim to get as many of the parameters I mentioned right.</p></section><div class="footnotes"><br/><hr class="footnote-hr"/><div id="ftn.good_code" class="footnote"><p><a href="../#good_code" class="para"><sup class="para">[having_good_code] </sup></a>What? Shouldn&#8217;t high quality software have a good codebase. Surprisingly no. What would you prefer: having a very modular codebase that does something pretty useless like outputting the string &#8220;Hello World&#8221; <span class="bold"><strong>or</strong></span> having a large codebase of relatively low quality with a large amount of useful functionality and relatively few bugs?</p><p>I would certainly prefer the other alternative. That&#8217;s because I know I can always refactor that codebase, either by <a class="link" href="http://www.joelonsoftware.com/articles/fog0000000348.html">large scale refactoring</a> or by continuous refactoring or even &#8220;Just-in-Time&#8221; refactoring, only to add a new feature.</p></div><div id="ftn.parameters-not-foss" class="footnote"><p><a href="../#parameters-not-foss" class="para"><sup class="para">[Licence] </sup></a>For example, I mention later that the more liberal the source licence of a program, the higher quality it is. Obviously, a lot of <a class="link" href="http://en.wikipedia.org/wiki/FOSS">non- &#8220;Free and Open Source Software&#8221;</a> or even binary-only applications are high-quality too. But, the use of such software is still more limited than an open-source one, so it would be of lesser quality than an identical software that is open-source.</p><p>Similarly, libraries or programs that are distributed under the relatively restrictive <a class="link" href="http://en.wikipedia.org/wiki/GNU_General_Public_License">GNU General Public Licence (GPL)</a> (and which are considered open-source and usable by most Linux distributions) cannot be used in many common situations, and so would be of lesser quality than programs under a more permissive licence.</p></div><div id="ftn.ideology" class="footnote"><p><a href="../#ideology" class="para"><sup class="para">[Ideology] </sup></a>Assuming there was ever a true ideology that was not also practical.</p><p>The way I see it, an ideology (and ethics in general) are a strategy that aims to make a person lead a better, happier life. If it isn&#8217;t, then it&#8217;s just a destructive dogma, or just plain stubbornness.</p></div><div id="ftn.public-domain-source" class="footnote"><p><a href="../#public-domain-source" class="para"><sup class="para">[public-domain] </sup></a>Using a pure-public-domain licensing terms for your software is problematic because not all countries have a concept of &#8220;public-domain&#8221;, similar to that of the United States, because many people misinterpret it, and because it is not clear whether software can be licensed under the public-domain to begin with. (And other such issues).</p><p>While <a class="link" href="http://freshmeat.net/browse/197/">quite a lot of important programs has been released under the public domain</a>, and they are doing quite fine, they may have some problematic legal implications.</p><p>For these reasons, I now prefer the MIT X11 Licence for software that I originated instead of the &#8220;public domain&#8221;.</p></div><div id="ftn.non-vax-archs" class="footnote"><p><a href="../#non-vax-archs" class="para"><sup class="para">[non-vax-like] </sup></a>I&#8217;m fully aware that before C-based UNIX and UNIX-like systems became dominant there were some more exotic architectures that could not run C comfortably. Prime examples for them are the <a class="link" href="http://en.wikipedia.org/wiki/PDP-10">PDP-10</a> and the <a class="link" href="http://en.wikipedia.org/wiki/Lisp_machine">Lisp machines</a>.</p><p>However, such more &#8220;unconventional&#8221; architectures are now dead, and no CPU architecture developer in their right mind would want to create a CPU that won&#8217;t be able to run C and C-based UNIX-based or UNIX-like operating systems such as Linux. (Unless it&#8217;s probably a relatively niche micro-processor for embedded systems).</p><p>Lisp, and similar higher-level languages, run on modern UNIX-based OSes very well, so there&#8217;s not a big problem there.</p></div><div id="ftn.software-only-on-linux" class="footnote"><p><a href="../#software-only-on-linux" class="para"><sup class="para">[linux-bsd-soft] </sup></a>Naturally, this is a problem with the fact that most developers are developing on Linux (mostly x86), don&#8217;t test it on other Unix flavours, and are too careless or unaware to write their programs portably enough.</p><p>However, it&#8217;s still a quality parameter, because it still affects the way you&#8217;re using the operating system.</p></div></div></section></main>
</div>
<footer>
<div class="foot_left">
<ul class="bt_nav">
<li><a href="../../../../../">Home</a></li>
<li><a href="../../../../../me/">About</a></li>
<li><a href="../../../../../me/contact-me/">Contact Us</a></li>
<li><a href="../../../../../meta/privacy-policy/">Privacy Policy</a></li>
<li><a href="../../../../../meta/anti-spam-policy/">Anti-Spam
Policy</a></li>
<li><a href="../../../../../meta/FAQ/" title=
"Frequently asked questions list">FAQ</a></li>
<li><a href="../../../../../me/blogs/">RSS/Atom Feeds</a></li>
</ul>
<p>Written, designed, and maintained by Shlomi Fish, <a href=
"mailto:shlomif@shlomifish.org">shlomif@shlomifish.org</a>.</p>
</div>
<a href="../../../../../"><img src="../../../../../images/bk2hp-v2.min.svg" class=
"bk2hp" alt="Back to my Homepage"/></a></footer>
</body>
</html>
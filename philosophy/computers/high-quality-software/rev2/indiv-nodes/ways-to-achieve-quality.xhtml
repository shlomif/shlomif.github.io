<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>What Makes Software High-Quality? (Revision 2) - Ways to Achieve Quality</title>
<meta charset="utf-8"/>
<meta name="description" content=
"What Makes Software High-Quality? (Revision 2) - Ways to Achieve Quality"/>
<link rel="stylesheet" href="../../../../../faq-indiv.css" media="screen"/>
<link rel="stylesheet" href="../../../../../screenplay.css" media="screen"
title="Normal"/>
<link rel="stylesheet" href="../../../../../print.css" media="print"/>
<link rel="shortcut icon" href="../../../../../favicon.ico" type=
"image/x-icon"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
</head>
<body class="fancy_sects faq_indiv_entry limit_imgs_width screenplay_indiv_entry">
<div class="header" id="header">
<a href="../../../../../"><img src="../../../../../images/evilphish-flipped.png"
alt="EvilPHish site logo"/></a>
<div class="leading_path"><a href="../../../../../">Shlomi Fish’s
Homepage</a> →
<a href="../" title="What Makes Software High-Quality? (Revision 2)">What Makes Software High-Quality? (Revision 2)</a>

→ <b>Ways to Achieve Quality</b>
</div>
</div>
<div id="faux">
<main class="main faq screenplay">
<section xmlns="http://www.w3.org/1999/xhtml" class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h3 id="ways-to-achieve-quality" class="title">Ways to Achieve Quality</h3><h:a class="back_to_faq" href="../#ways-to-achieve-quality">Node Link</h:a></header><p>Now that we&#8217;ve covered the elements that make programs high-quality here&#8217;s a non-exhaustive list of ways to actually achieve it. None of them are absolutely necessary for achieving the quality, but they certainly help a lot.</p><p>Many people often confuse them with quality. &#8220;This software has God-damn awful code, so it&#8217;s a pile-of-crap.&#8221; Well, what do the users care how bad the code is, as long as it is functional, has all the necessary features, and is (mostly) bug-free? It&#8217;s important not to confuse quality with the ways to achieve it.</p><p>The aim of this section is to briefly cover as many measures for achieving good quality as possible.</p><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="modular-code" class="title">Having Modular, Well-Written Code</h4></header><p>The more modular a project&#8217;s code is, the easier it is to change it, understand it and extend it, and the faster development will take. <a class="link" href="http://www.refactoring.com/">Refactoring</a> is the name given to the process used to transform code from sub-optimal and &#8220;ugly&#8221;, but still mostly functional and bug-free code, to a code that is equally functional but more modular and clean. See <a class="link" href="http://www.joelonsoftware.com/articles/fog0000000348.html">the <span class="emphasis"><em>Joel on Software</em></span> excellent article &#8220;Rub a dub dub&#8221;</a> for some of the motivation and practices of good refactoring instead of throwing away the code and restarting from scratch.</p><p>A reviewer of an early version of this article told me about an early and relatively large PHP code of her that was badly written, relatively buggy and yet proved to be popular among some of her clients, who have deployed it on many hosts and won&#8217;t effectively upgrade it. So she still has to maintain it, even though she&#8217;d rather not recommend it. She claimed that this is an indication that such low-quality in code, is a criterion of low-quality.</p><p>She has a point in the fact that usually badly-written or non-modular code results in more external low-quality factors such as bugs, security problems and lack of extensibility. However, even if the code was extremely well-written it is likely that it would need to be maintained, extended, and corrected. And if the clients in question don&#8217;t have or don&#8217;t want a good way to pull changes from a central place, or install updates properly, it&#8217;s a procedural and organisational problem.</p><p>Organisational quality deserves its own separate article (or arguably book, web-site, or even more than one book), but external software quality (much less internal one), is not a substitute for it. Please refer to <a class="link" href="http://www.shlomifish.org/philosophy/philosophy/advice-for-the-young/#recommended_writings">a partial list I prepared on a different article</a>, and my <a class="link" href="http://www.shlomifish.org/links.html#software_gurus">software &#8220;gurus&#8221; links</a> on my home-site&#8217;s links&#8217; list.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="automated-tests" class="title">Automated Tests</h4></header><p>Automated tests aim to test the behaviour of code automatically, instead of manual testing. The classical example for them is that if we wish to write a function called <code class="literal">add(i, j)</code> that aims to add two integers then we should check that <code class="literal">add(2, 3) == 5</code>, that <code class="literal">add(2, 0) == 2</code>, that <code class="literal">add(0, 2) == 2</code>, that <code class="literal">add(5, -2) == 3</code>, that <code class="literal">add(10, -24) == -14</code>, etc.</p><p>Then we can run all the tests and if any of them failed, we can fix them. Then after we write or modify the code, we can test using them again to see if there are any regressions.</p><p>Writing automated tests before we write the actual code, or before we fix a bug, and accumulating such tests (the so-called <a class="link" href="http://en.wikipedia.org/wiki/Test-driven_development">&#8220;Test-driven development&#8221;</a> paradigm), is a good practice which helps maintain high-quality code, and facilitates refactoring and makes it safer.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="beta-testers" class="title">Beta Testers</h4></header><p>If you have beta testers for the code, or publish development versions frequently, you can get a lot of feedback for various different platforms and configurations your code is running on. These beta-testers can run the automated tests and also use the beta-code for their own testing or even production.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="frequent-releases" class="title">Frequency of Releases</h4></header><p>The more frequent your releases are, the more people can test your code, and the more they can upgrade to the latest version, and the quicker bugs that disturb your users are fixed, etc.</p><p>Naturally, there are advantages for slower release cycles, or for predictable release cycles like <a class="link" href="http://www.gnome.org/">GNOME 2.x</a> has. I won&#8217;t voice a definite opinion for which is the best methodology, but such a decision should be taken into consideration.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="good-software-management" class="title">Good Software Management</h4></header><p>There are several sources, online and offline, explaining good software management for &#8220;shrinkwrap&#8221; software (open-source, commercial or other distributed) and for other types of software development (embedded, in-house, etc.), from which good advice can be taken for how to best run a software project. While they are sometimes contradictory, and often false, they still make a good read and are thought-provoking.</p><p>Here are some links:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><a class="link" href="http://www.catb.org/~esr/writings/cathedral-bazaar/">Eric Raymond&#8217;s &#8220;The Cathedral and the Bazaar&#8221; series</a></p></li><li class="listitem"><p><a class="link" href="http://www.joelonsoftware.com/">The <span class="emphasis"><em>Joel on Software</em></span> site</a></p></li><li class="listitem"><p><a class="link" href="http://www.paulgraham.com/">Paul Graham&#8217;s Essays</a> (on various topics)</p></li><li class="listitem"><p><a class="link" href="http://www.extremeprogramming.org/">Extreme Programming</a></p></li></ol></div></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="tactfullness" class="title">Good Social Engineering Skills</h4></header><p>It certainly helps for the project&#8217;s communities to have good social engineering skills. From tactfulness, to humour, to controlling one&#8217;s temper, to saying &#8220;Thanks&#8221; and congratulating people for their contribution, to timely applying patches and fixing bugs - all of these makes contributing to a project and using the program more fun and less frustrating.</p><p>Often, social engineering should be made part of the design of the software, or the web-sites dedicated to it. For example, it took me several iterations of having to fill the same project form in <a class="link" href="http://savannah.gnu.org/">the GNU Savannah software-hub</a>, only for it to be rejected, and me having to follow the process again. Despite the fact the admins were polite, it still was annoying.</p><p>Eventually, they implemented a way to save previous project submissions and to re-send them, so future users won&#8217;t become as frustrated as I did.</p><p>Again, some projects have succeeded despite the fact they had, or even still have, bad social engineering. But adopting a good software engineering policy can certainly help a lot.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="bad-politics" class="title">No Bad Politics</h4></header><p>Bad politics in a software project is a lot like subjectivity, <a class="link" href="http://shlomif.livejournal.com/52439.html">it can never be fully eliminated, but we should still strive to reduce it to the minimum.</a>. If bad political processes become common in a project, then important features are dropped, bugs are left unfixed, patches are stalled, external projects gets stalled or are killed, people become frustrated or angry and possibly leave the project - and the project may risk forking.</p><p>So it&#8217;s a good idea to keep bad politics at bay and to a minimum. How to do that is out of the scope of the document, but it&#8217;s usually up to the leaders to keep it so and maintain a good policy that will make as few people as possible frustrated and will not flabbergast external contributors. And naturally, for open-source and similar projects, a fork is often an option in this case, or in other similar cases.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="good-communication-skills" class="title">Good Communication Skills</h4></header><p>A project leader and other participants should have good communication skills: very good English; pleasantness and tact; good phrasing, proper grammar, syntax, phrasing and capitalisation; clear writing; patience and tolerance; etc. If they don&#8217;t, then the project may encounter problems as people will find the project&#8217;s developers hard to understand or tolerate, and, thus, hard to work with.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="hype" class="title">Hype</h4></header><p>Despite common belief I believe that the less hype and general noise there is regarding a software project, the better off it is. For example, as <a class="link" href="http://www.paulgraham.com/javacover.html">Paul Graham notes regarding Java</a>:</p><div class="blockquote"><blockquote class="blockquote"><p>[Java] has been so energetically hyped. Real standards don&#8217;t have to be promoted. No one had to promote C, or Unix, or HTML. A real standard tends to be already established by the time most people hear about it. On the hacker radar screen, Perl is as big as Java, or bigger, just on the strength of its own merits.</p></blockquote></div><p>In fact, I can argue that if your project receives a lot of negative hype, then it is an indication that it is successful. Perl, for example, <a class="link" href="http://perl-begin.org/learn/myth-dispelling/">has received (and still receives) a lot of criticism</a>, and Perl aficionados often get tired of constantly hearing or seeing the same repetitive and tired arguments by its opponents. However, the perl 5 interpreter is in good shape, it has many automated tests (much more than most other competing dynamic languages), an active community, many modules on CPAN ( the Comprehensive Perl Archive Network) with a lot of third-party , open-source functionality, and relatively few critical bugs. It is still heavily actively used and has many fans.</p><p>Similar criticism has been voiced against <a class="link" href="http://subversion.tigris.org/">the Subversion version control system</a>, Linux, etc. One thing one can notice about such highly-criticised projects is that they tend not to be bothered by it too much. Rather, what they say is that &#8220;If you want to use a competing project, I won&#8217;t stop you. It probably is good. It may be better in some respects. I like my own project and that&#8217;s what I&#8217;m used to using and use.&#8221;</p><p>This is by all means the right policy of &#8220;hyping&#8221; to adopt, if you want your project to be successful based on its own merits. Some projects compete for the same niche, without voicing too much hype against each other or for them, and this is a better indication that they are all healthy.</p></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="good-name" class="title">A Good Name</h4></header><p>Finally, a project should have a good name. One example for a project with an awful name is <a class="link" href="http://www.march-hare.com/cvspro/">CVSNT</a>. There are two problems with the name:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>It is based on CVS, which most people have ran into its limitations, is considered pass&#233; and unloved, and people would rather avoid.</p></li><li class="listitem"><p>The &#8220;NT&#8221; part implies it only runs on Windows-NT, which is both misleading and undesirable.</p></li></ol></div><p>On the other hand, the competing project &#8220;Subversion&#8221; has a much better name, since it has nothing to do with CVS, or Windows NT, and since it is an English word and sounds cool.</p><p>Some projects are successful despite being badly named, while some have a very cool name, but languish. Still, a good name helps a lot.</p><p>Also consider what <a class="link" href="http://groups.google.com/group/comp.unix.pc-clone.32bit/msg/80bb74847934edc7">Linus Torvalds said about Linux and 386BSD</a> (half jokingly):</p><div class="blockquote"><blockquote class="blockquote"><p>No. That&#8217;s it. The cool name, that is. We worked very hard on creating a name that would appeal to the majority of people, and it certainly paid off: thousands of people are using linux just to be able to say &#8220;OS/2? Hah. I&#8217;ve got Linux. What a cool name&#8221;. 386BSD made the mistake of putting a lot of numbers and weird abbreviations into the name, and is scaring away a lot of people just because it sounds too technical.</p></blockquote></div></section><section class="section"><header xmlns:h="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" class="titlepage"><h4 id="measures-conclusion" class="title">Conclusion</h4></header><p>Entire books (and web-sites) were filled with the various measures to achieve software quality, and what I described here was just a sample of it. The point is that these are not aspects of quality by themselves, but rather measures that help. None of them is a required or adequate condition for the success of a project, but the more are implemented the easier, faster, and more enjoying working on the project will be.</p></section></section></main>
</div>
<footer>
<div class="foot_left">
<ul class="bt_nav">
<li><a href="../../../../../">Home</a></li>
<li><a href="../../../../../me/">About</a></li>
<li><a href="../../../../../me/contact-me/">Contact Us</a></li>
<li><a href="../../../../../meta/privacy-policy/">Privacy Policy</a></li>
<li><a href="../../../../../meta/anti-spam-policy/">Anti-Spam
Policy</a></li>
<li><a href="../../../../../meta/FAQ/" title=
"Frequently asked questions list">FAQ</a></li>
<li><a href="../../../../../me/blogs/">RSS/Atom Feeds</a></li>
</ul>
<p>Written, designed, and maintained by Shlomi Fish, <a href=
"mailto:shlomif@shlomifish.org">shlomif@shlomifish.org</a>.</p>
</div>
<a href="../../../../../"><img src="../../../../../images/bk2hp-v2.min.svg" class=
"bk2hp" alt="Back to my Homepage"/></a></footer>
</body>
</html>
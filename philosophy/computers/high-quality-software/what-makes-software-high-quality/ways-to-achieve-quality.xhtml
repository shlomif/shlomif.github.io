<?xml version="1.0" encoding="UTF-8"?><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>Ways to Achieve Quality</title><link rel="stylesheet" type="text/css" href="docbook.css"/><link rel="stylesheet" type="text/css" href="style.css"/><meta name="generator" content="DocBook XSL Shlomif"/><link rel="prev" href="parameters-of-quality.xhtml" title="Parameters of Quality"/><link rel="next" href="freecell-solvers-quality.xhtml" title="Analysis of the Quality of the Various Freecell Solvers"/></head><body><header><div class="center ads_top"/><div class="navheader"><table style="width:100%"><tr><th style="text-align:center" colspan="3">Ways to Achieve Quality</th></tr><tr><td style="width:20%;text-align:left"><a accesskey="p" href="parameters-of-quality.xhtml">Prev</a> </td><th style="width:60%;text-align:center"> </th><td style="width:20%;text-align:right"> <a accesskey="n" href="freecell-solvers-quality.xhtml">Next</a></td></tr></table><hr/></div></header><section class="section"><div class="titlepage"><div><div><h2 id="ways-to-achieve-quality" class="title">Ways to Achieve Quality</h2></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="ways-to-achieve-quality.xhtml#modular-code">Having Modular, Well-Written Code</a></span></li><li><span class="section"><a href="ways-to-achieve-quality.xhtml#automated-tests">Automated Tests</a></span></li><li><span class="section"><a href="ways-to-achieve-quality.xhtml#beta-testers">Beta Testers</a></span></li><li><span class="section"><a href="ways-to-achieve-quality.xhtml#frequent-releases">Frequency of Releases</a></span></li><li><span class="section"><a href="ways-to-achieve-quality.xhtml#good-software-management">Good Software Management</a></span></li><li><span class="section"><a href="ways-to-achieve-quality.xhtml#tactfullness">Good Social Engineering Skills</a></span></li><li><span class="section"><a href="ways-to-achieve-quality.xhtml#bad-politics">No Bad Politics</a></span></li><li><span class="section"><a href="ways-to-achieve-quality.xhtml#good-communication-skills">Good Communication Skills</a></span></li><li><span class="section"><a href="ways-to-achieve-quality.xhtml#hype">Hype</a></span></li><li><span class="section"><a href="ways-to-achieve-quality.xhtml#good-name">A Good Name</a></span></li><li><span class="section"><a href="ways-to-achieve-quality.xhtml#measures-conclusion">Conclusion</a></span></li></ul></div><p>Now that we've covered the elements that make programs high-quality here's a non-exhaustive list of ways to actually achieve it. None of them are absolutely necessary for achieving the quality, but they certainly help a lot.</p><p>Many people often confuse them with quality. "This software has God-damn awful code, so it's a pile-of-crap." Well, what do the users care how bad the code is, as long as it is functional, has all the necessary features, and is (mostly) bug-free? It's important not to confuse quality with the ways to achieve it.</p><p>The aim of this section is to briefly cover as many measures for achieving good quality as possible.</p><section class="section"><div class="titlepage"><div><div><h3 id="modular-code" class="title">Having Modular, Well-Written Code</h3></div></div></div><p>The more modular a project's code is, the easier it is to change it, understand it and extend it, and the faster development will take. <a class="link" href="http://www.refactoring.com/">Refactoring</a> is the name given to the process used to transform code from sub-optimal and "ugly", but still mostly functional and bug-free code, to a code that is equally functional but more modular and clean. See <a class="link" href="http://www.joelonsoftware.com/articles/fog0000000348.html">the "Joel on Software" excellent article "Rub a dub dub"</a> for some of the motivation and practices of good refactoring instead of throwing away the code and restarting from scratch.</p></section><section class="section"><div class="titlepage"><div><div><h3 id="automated-tests" class="title">Automated Tests</h3></div></div></div><p>Automated tests aim to test the behaviour of code automatically, instead of manual testing. The classical example for them is that if we wish to write a function called <code class="literal">add(i, j)</code> that aims to add two integers then we should check that <code class="literal">add(2, 3) == 5</code>, that <code class="literal">add(2, 0) == 2</code>, that <code class="literal">add(0, 2) == 2</code>, that <code class="literal">add(5, -2) == 3</code>, that <code class="literal">add(10, -24) == -14</code>, etc.</p><p>Then we can run all the tests and if any of them failed, we can fix them. Then after we write or modify the code, we can test using them again to see if there are any regressions.</p><p>Writing automated tests before we write the actual code, or before we fix a bug, and accumulating such tests (the so-called <a class="link" href="http://en.wikipedia.org/wiki/Test-driven_development">"Test-driven development"</a> paradigm), is a good practice which helps maintain a high-quality software, and facilitates refactoring and makes it safer.</p></section><section class="section"><div class="titlepage"><div><div><h3 id="beta-testers" class="title">Beta Testers</h3></div></div></div><p>If you have beta testers for the code, or publish development versions frequently, you can get a lot of feedback for various different platforms and configurations your code is running on. These beta-testers can run the automated tests and also use the beta-code for their own testing or even production.</p></section><section class="section"><div class="titlepage"><div><div><h3 id="frequent-releases" class="title">Frequency of Releases</h3></div></div></div><p>The more frequent your releases are, the more people can test your code, and the more they can upgrade to the latest version, and the quicker bugs that disturb your users are fixed, etc.</p><p>Naturally, there are advantages for slower release cycles, or for predictable release cycles like <a class="link" href="http://www.gnome.org/">GNOME 2.x</a> has. I won't voice a definite opinion for which is the best methodology, but such a decision should be taken into consideration.</p></section><section class="section"><div class="titlepage"><div><div><h3 id="good-software-management" class="title">Good Software Management</h3></div></div></div><p>There are several sources online and offline explaining good software management for "shrinkwrap" software (open-source, commercial or other distributed) and for other types of software development (embedded, in-house, etc.), from which good advice can be taken for how to best run a software project. While the are sometimes contradictory, and often false, they still make a good read and are thought-provoking.</p><p>Here are some links:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><a class="link" href="http://www.catb.org/~esr/writings/cathedral-bazaar/">Eric Raymond's "The Cathedral and the Bazaar" series</a></p></li><li class="listitem"><p><a class="link" href="http://www.joelonsoftware.com/">The "Joel on Software" site</a></p></li><li class="listitem"><p><a class="link" href="http://www.paulgraham.com/">Paul Graham's Essays</a> (on various topics)</p></li><li class="listitem"><p><a class="link" href="http://www.extremeprogramming.org/">Extreme Programming</a></p></li></ol></div></section><section class="section"><div class="titlepage"><div><div><h3 id="tactfullness" class="title">Good Social Engineering Skills</h3></div></div></div><p>It certainly helps for the project's communities to have good social engineering skills. From tactfulness, to humour, to controlling one's temper, to saying "Thanks" and congratulating people for their contribution, to timely applying patches and fixing bugs - all of these makes contributing to a project and using the program more fun and less frustrating.</p><p>Often, social engineering should be made part of the design of the software, or the web-sites dedicated to it. For example, it took me several iterations of having to fill the same project form in <a class="link" href="http://savannah.gnu.org/">the GNU Savannah software-hub</a>, only for it to be rejected, and me having to follow the process again. Despite the fact the admins were polite, it still was annoying.</p><p>Eventually, they implemented a way to save previous project submissions and to re-send them, so future users won't become as frustrated as I did.</p><p>Again, some projects have succeeded despite the fact they had, or even still have, bad social engineering. But adopting a good software engineering policy can certainly help a lot.</p></section><section class="section"><div class="titlepage"><div><div><h3 id="bad-politics" class="title">No Bad Politics</h3></div></div></div><p>Bad politics in a software project is a lot like subjectivity, <a class="link" href="http://shlomif.livejournal.com/52439.html">it can never be fully eliminated, but we should still strive to reduce it to the minimum.</a>. If bad political processes become common in a project, then important features are dropped, bugs are left unfixed, patches are stalled, external projects gets stalled or are killed, people become frustrated or angry and possibly leave the project - and the project may risk forking.</p><p>So it's a good idea to keep bad politics at bay and to a minimum. How to do that is out of the scope of the document, but it's usually up to the leaders to keep it so and maintain a good policy that will make as few people as possible frustrated and will not flabbergast external contributors. And naturally, for open-source and similar projects, a fork is often an option in this case, or in other similar cases.</p></section><section class="section"><div class="titlepage"><div><div><h3 id="good-communication-skills" class="title">Good Communication Skills</h3></div></div></div><p>A project leader and other participants should have good communication skills: very good English; pleasantness and tact; good phrasing, proper grammar, syntax, phrasing and capitalisation; clear writing; patience and tolerance; etc. If he doesn't, then the project may encounter problems as people will find the project's developers hard to understand or tolerate, and, thus, hard to work with.</p></section><section class="section"><div class="titlepage"><div><div><h3 id="hype" class="title">Hype</h3></div></div></div><p>Despite common belief I believe that the less hype and general noise there is regarding a software project, the better off it is. For example, as <a class="link" href="http://www.paulgraham.com/javacover.html">Paul Graham notes regarding Java</a>:</p><div class="blockquote"><blockquote class="blockquote"><p>[Java] has been so energetically hyped. Real standards don't have to be promoted. No one had to promote C, or Unix, or HTML. A real standard tends to be already established by the time most people hear about it. On the hacker radar screen, Perl is as big as Java, or bigger, just on the strength of its own merits.</p></blockquote></div><p>In fact, I can argue that if your project receives a lot of negative hype, then it is an indication that it is successful. Perl, for example, <a class="link" href="http://perl-begin.org/learn/myth-dispelling/">has received (and still receives) a lot of criticism</a>, and Perl aficionados often get tired of constantly hearing or seeing the same repetitive and tired arguments by its opponents. However, the perl 5 interpreter is in good shape, it has many automated tests (much more than most other competing dynamic languages), an active community, many modules on CPAN ( the Comprehensive Perl Archive Network) with a lot of third-party , open-source functionality, and relatively few critical bugs. It is still heavily actively used and has many fans.</p><p>Similar criticism has been voiced against <a class="link" href="http://subversion.tigris.org/">the Subversion version control system</a>, Linux, etc. One thing one can notice about such highly-criticised projects is that they tend not to be bothered by it too much. Rather, what they say is that "If you want to use a competing project, I won't stop you. It probably is good. It may be better in some respects. I like my own project and that's what I'm used to using and use."</p><p>This is by all means the right policy of "hyping" to adopt, if you want your project to be successful based on its own merits. Some projects compete for the same niche, without voicing too much hype against each other or for them, and this is a better indication that they are all healthy.</p></section><section class="section"><div class="titlepage"><div><div><h3 id="good-name" class="title">A Good Name</h3></div></div></div><p>Finally, a project should have a good name. One example for a project with an awful name is <a class="link" href="http://www.march-hare.com/cvspro/">CVSNT</a>. There are two problems with the name:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>It is based on CVS, which most people have ran into its limitations, is considered passé and unloved, and people would rather avoid.</p></li><li class="listitem"><p>The "NT" part implies it only runs on Windows-NT, which is both misleading and undesirable.</p></li></ol></div><p>On the other hand, the competing project "Subversion" has a much better name, since it has nothing to do with CVS, or Windows NT, and since it is an English word and sounds cool.</p><p>Some projects are successful despite being badly named, while some have a very cool name, but languish. Still, a good name helps a lot.</p><p>Also consider what <a class="link" href="http://groups.google.com/group/comp.unix.pc-clone.32bit/msg/80bb74847934edc7">Linus Torvalds said about Linux and 386BSD</a> (half jokingly):</p><div class="blockquote"><blockquote class="blockquote"><p>No. That's it. The cool name, that is. We worked very hard on creating a name that would appeal to the majority of people, and it certainly paid off: thousands of people are using linux just to be able to say "OS/2? Hah. I've got Linux. What a cool name". 386BSD made the mistake of putting a lot of numbers and weird abbreviations into the name, and is scaring away a lot of people just because it sounds too technical.</p></blockquote></div></section><section class="section"><div class="titlepage"><div><div><h3 id="measures-conclusion" class="title">Conclusion</h3></div></div></div><p>Entire books (and web-sites) were filled with the various measures to achieve software quality, and what I described here was just a sample of it. The point is that these are not aspects of quality by themselves, but rather measures that help. None of them is a required or adequate condition for the success of a project, but the more are implemented the easier, faster, and more enjoying working on the project will be.</p></section></section><footer><div class="navfooter"><hr/><table style="width:100%"><tr><td style="width:40%;text-align:left"><a accesskey="p" href="parameters-of-quality.xhtml">Prev</a> </td><td style="width:20%;text-align:center"> </td><td style="width:40%;text-align:right"> <a accesskey="n" href="freecell-solvers-quality.xhtml">Next</a></td></tr><tr><td style="width:40%;text-align:left;vertical-align:top">Parameters of Quality </td><td style="width:20%;text-align:center"><a accesskey="h" href="index.xhtml">Home</a></td><td style="width:40%;text-align:right;vertical-align:top"> Analysis of the Quality of the Various Freecell Solvers</td></tr></table></div></footer></body></html>
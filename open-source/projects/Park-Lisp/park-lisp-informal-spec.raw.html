<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>Park - Park is, is not, is too, is not Arc</title><link rel="stylesheet" type="text/css" href="style.css"/><meta name="generator" content="DocBook XSL Shlomif"/><link rel="next" href="#about_park" title="Park - Park is, is not, is too, is not Arc"/></head><body><header><div class="center ads_top"/></header><section xml:lang="en" class="article"><div class="titlepage"><div><div><h1 id="index" class="title">Park - Park is, is not, is too, is not Arc</h1></div><div><div class="authorgroup"><div class="author"><h2 class="author"><span class="firstname">Shlomi</span> <span class="surname">Fish</span></h2><div class="affiliation"><div class="address"><p><br/>                        <code class="email">&lt;<a class="email" href="mailto:shlomif@shlomifish.org">shlomif@shlomifish.org</a>&gt;</code><br/>                        <code class="uri"><a class="uri" href="http://www.shlomifish.org/">Shlomi Fish’s Homepage</a></code><br/>                    </p></div></div></div></div></div><div><p class="copyright">Copyright © 2004 Shlomi Fish</p></div><div><div id="legalnotice" class="legalnotice"><p>This document is copyrighted by Shlomi Fish under the <a class="link" href="http://creativecommons.org/licenses/by/2.5/">Creative Commons Attribution License version 2.5</a> (or at your option a greater version). The code samples are under the Public Domain.</p></div></div><div><div class="revhistory"><table><tr><th colspan="3"><strong>Revision History</strong></th></tr><tr><td>Revision 3</td><td>2006-06-21</td><td>shlomif</td></tr><tr><td colspan="3">Started working on this document after forking the template of an older one.</td></tr></table></div></div></div><hr/></div><section class="section"><div class="titlepage"><div><div><h3 id="about_park" class="title">Park - Park is, is not, is too, is not Arc</h3></div></div></div><p id="about_the_slogan">Park <a href="#ftn.about_the_slogan" class="footnote"><sup class="footnote">[1]</sup></a> is a new dialect of Lisp, based on <a class="link" href="http://www.paulgraham.com/arc.html">Paul Graham's Arc effort</a>. Park is in fact a malicious and incompatible fork of Arc. A fork not of the code, which is still not available to the public, but of the concept and motivation.</p><p>The origin of the name is with an initial implementation for Arc that I wanted to write for Parrot, called PArc or Parc. However, then I realised I disagree with Graham about some of his language design elements. A few days ago I came with a revelation that it was hopeless waiting for Mr. Graham to actually release either a final spec to the public of Arc or a actual working code. Arc <a class="link" href="http://www.paulgraham.com/arcll1.html">was announced at the LL1 conference at November 2001</a>. It's been almost 5 years from now, and there's still not a working code or a coherent spec. Furthermore, Graham stopped adding the ideas people sent him to the <a class="link" href="http://www.archub.org/arcsug.txt">emails collection containing them</a> (including one that I sent a few years ago, which I know he is aware of because he responded to my message).</p><p>Thus enter Park. The name stems from "Parc" but is actually an English world. One can say that Park is a LISP that starts with "P", or that working with it is like a stroll in the Park. Park has <a class="link" href="http://www.paulgraham.com/popular.html">the design goals of Arc</a> but:</p><p></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Is different and incompatible.</p></li><li class="listitem"><p>Has a working (albeit so far informal) spec.</p></li><li class="listitem"><p>Encourages participation from the community (using such web resources as a Subversion repository, a Wiki, etc.)</p></li><li class="listitem"><p>Encourages people to create and hack on implementations for it.</p></li><li class="listitem"><p>Would try to get version 0.2.0 of the SPEC (the first stable version of the language) out of the door as soon as possible, so people can create implementations that they can rely on.</p></li></ol></div><p></p><p>One note about myself. My name is <a class="link" href="http://www.shlomifish.org/">Shlomi Fish</a> and I'm a software enthusiast and a writer. I am not the ideal person to design Park, but I believe and hope that I have the right attitude. If you happen to know better about some things, please post your corrections to the mailing lists to the mailing list. Corrections in the form of patches against the Docbook/XML source are preferable. Several of them or even just one that is accepted will get you a Subversion commit access. And naturally everyone can edit the wiki.</p><section class="section"><div class="titlepage"><div><div><h4 id="why_am_i_doing_it" class="title">Why am I Doing it?</h4></div></div></div><div class="blockquote"><table style="border:0" class="blockquote"><tr><td style="width:10%;vertical-align:top"> </td><td style="width:80%;vertical-align:top"><p>All language designers are arrogant. Comes with the territory.</p></td><td style="width:10%;vertical-align:top"> </td></tr><tr><td style="width:10%;vertical-align:top"> </td><td style="text-align:right;vertical-align:top" colspan="2">--<span class="attribution"><a class="link" href="http://groups.google.com/group/comp.lang.perl/msg/620a1599759c9bc?hl=en">Larry Wall</a></span></td></tr></table></div><p>Why am I doing it? For several reasons:</p><p></p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p><a class="link" href="http://www.amazon.com/gp/product/0066620724/103-5528911-1875020">Because it's fun.</a> This is by itself a good reason.</p></li><li class="listitem"><p>Because I found that designing your own language is one of the best ways to learn more about the original languages it is based on. When I designed the <a class="link" href="http://www.shlomifish.org/rindolf/">Perl dialect "Rindolf"</a>, I learned that some features I suggested for it were already doable in Perl 5.</p></li><li class="listitem"><p>Because something good may eventually come out of it. The existing popular dialects of LISP are Common LISP, Scheme (which some people claim is not entirely Lispy) and some domain-specific Lisp dialects like Emacs Lisp and Autolisp, which are not useful for general programming.</p><p>The Common Lisp and Scheme standards still exhibit some relics of the Lisp distant past, where it was expected to run on such now obscure systems as <a class="link" href="http://en.wikipedia.org/wiki/PDP-10">the PDP-10</a> and <a class="link" href="http://en.wikipedia.org/wiki/Incompatible_Timesharing_System">ITS</a> or the LISP Machine. They do not correspond to the modern's world "All the world is a VAX" and "Everything on top is a UNIX" reality. (Which has persisted for better or for worse).</p><p>The implementations themselves do little to solve this problem, as they differ in the APIs they provide for such basic mechanisms that programmers of other dynamic languages (like Perl, Python, PHP, Ruby or Tcl) take for granted like Random File I/O, Sockets, Regular Expressions, CGI Programming and Web Automation, Graphical User-interface, Database Connectivity etc.</p></li></ol></div><p></p></section><section class="section"><div class="titlepage"><div><div><h4 id="why_a_new_dialect" class="title">Why a new Dialect?</h4></div></div></div><p>Paul Graham explains it very well in <a class="link" href="http://www.paulgraham.com/arcfaq.html">the Arc FAQ</a>, and in <a class="link" href="http://www.paulgraham.com/popular.html">"Being Popular"</a>. Park is Arc done faster, and hopefully also better.</p></section></section><section class="section"><div class="titlepage"><div><div><h3 id="what_park_is_based_on" class="title">What Park is based on</h3></div></div></div><p>The following languages have influenced Park:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Arc and Scheme. And to some extent Common LISP.</p></li><li class="listitem"><p>Perl 5 and Perl 6.</p></li><li class="listitem"><p>Python.</p></li><li class="listitem"><p>Smalltalk and Ruby.</p></li></ol></div></section><section class="section"><div class="titlepage"><div><div><h3 id="elements_of_design" class="title">Elements of Design</h3></div></div></div><section class="section"><div class="titlepage"><div><div><h4 id="arc_is_object_oriented" class="title">Arc is Object Oriented (Everything is an Object)</h4></div></div></div><p>Paul Graham wrote <a class="link" href="http://www.paulgraham.com/noop.html">Why Arc isn't Especially Object-Oriented.</a>. His conclusion for why this is the case are:</p><div class="blockquote"><blockquote class="blockquote"><p>I personally have never needed object-oriented abstractions. Common Lisp has an enormously powerful object system and I've never used it once. I've done a lot of things (e.g. making hash tables full of closures) that would have required object-oriented techniques to do in wimpier languages, but I have never had to use CLOS.</p><p>Maybe I'm just stupid, or have worked on some limited subset of applications. There is a danger in designing a language based on one's own experience of programming. But it seems more dangerous to put stuff in that you've never needed because it's thought to be a good idea.</p></blockquote></div><p>Well, maybe it's because I'm younger, but having worked with Perl 5 extensively, I've used its object system (and some OO-support modules) a lot. While I have inherited some classes in Perl 5, I also often use an object just to make sure it can be instantiated.</p><p>Furthermore, having learned a bit about Perl 6 and Ruby, I believe that making everything an object, can be advantageous because one can more easily inherit from it, and add methods (and multimethods) to constants or regular variables (e.g: <span class="quote">“<span class="quote">6-&gt;my_func();</span>”</span>), or even easily override default behaviour.</p><p>So there we go. Note that Park will not be overly-Object-Oriented (OOO). One would be able to declare global functions and variables, and write scripts or modules without wrapping it in Objects. (Read what <a class="link" href="http://www.builderau.com.au/program/0,39024614,39160082,00.htm">Damian Conway has to say about the Hello World program in Java</a> for why I don't like it).</p><p>Here are some features of the object system:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Supports multiple-inheritance.</p></li><li class="listitem"><p>Methods can be added to classes at run-time (like Smalltalk or Ruby).</p></li><li class="listitem"><p>Supports <a class="link" href="http://use.perl.org/~Ovid/journal/27656">traits</a> (or as the Perl 6 people call them "Roles").</p></li><li class="listitem"><p>The fields of every object will be stored as an associative array, accessible using a special method. (This associative array will also be an object since everything is. I wonder how the Python people have solved it, but it's probably doable.)</p></li><li class="listitem"><p>The member variables of every object will be stored as an associative array, accessible using a special method. (This associative array will also be an object since everything is. I wonder how the Python people have solved it, but it's probably doable.)</p></li><li class="listitem"><p>Similarly to Perl5 and Python (and as opposed to Java, C++ or PHP) there won't be any built-in "public", "protected", "private", etc. access-control for methods of objects by default. Such things can probably be implemented by tweaking the method class and/or the class meta-class, or in different ways completely, but I don't find it appropriate for Park.</p></li><li class="listitem"><p>Multi-methods will be supported. Multimethods are functions that are dispatched according to more than one object based on the best matching multimethod signature. The syntax for this would be the mcall function (short for multi-call):</p><pre class="programlisting">
(mcall my-multi-method ([ object1 object2 object3])
    optional-param1 optional-param2 optional-param3
)
</pre><p>The standard way to invoke a method is to use the <code class="literal">call</code> function, which propagates according to only a single argument:</p><pre class="programlisting">
(def-method "MyClass::init"
    ((this)
        (set (this sum) 0)
    )
)
(def-method "MyClass::add"
    ((this n)
        (+= (-&gt; this sum) n)
    )
)
(def-method "MyClass::getsum"
    ((this)
        (-&gt; this sum)
    )
)
(set new-summer (new MyClass))
(call add new-summer 5)
(call add new-summer 7)
(call add new-summer 13)
(print (call getsum new-summer) "\n")
</pre><p>This will print 24 and a newline.</p><p>Note that usually the call would be redundant, and you could use a simple function call. However, such a function call would be subject to other Perl 5-like calling semantics.</p></li></ol></div></section><section class="section"><div class="titlepage"><div><div><h4 id="lexical_scoping_and_dynamic_scoping" class="title">Lexical Scoping and Dynamic Scoping</h4></div></div></div><p>Scheme and Common Lisp which are the most modern popular LISP dialects use lexical scoping, and since Perl 5 adopted it, it has been become very popular and mainstream, outside Lisp.</p><p>The default localization of values in Park would be lexical. However, having used Perl 5's <code class="literal">local</code>, I am aware of <a class="link" href="http://perl.plover.com/local.html">several good uses for dynamic scoping in a mostly lexical scoping language</a>. So, there will be a way to localise variables dynamically in Park.</p><p>One killer feature like that would be a way to do something like:</p><pre class="programlisting">
(do-using-local-state
    (
        (set a "hello")
        (my-func-with-side-effects)
    )
    (
        # Rest of code here.
    )
)
# a is no longer hello and (my-func-with-side-effects) effects' are reversed.
</pre><p>Of course, this feature is still pie-in-the-sky, and I'm waiting for a good analysis of complexity and/or efficient working implementation.</p></section><section class="section"><div class="titlepage"><div><div><h4 id="full_posix_conventions" class="title">Park would be Fully POSIX</h4></div></div></div><p>Park will be expected to run on a Unix or a Unix-like system (such as Win32) and will provide APIs for such common POSIX and P-Languages operations as random file I/O, sockets, regular expressions, manipulating ASCII text, Unicode and other encodings. It may also have platform-specific modules for managing processes, creating new processes, etc. (as is the case for Perl 5, for example.)</p><p>All of these things will eventually be part of the Park spec, and their APIs would be common to all implementations.</p><section class="section"><div class="titlepage"><div><div><h5 id="monads_for_files" class="title">Thoughts about using Monads for Files</h5></div></div></div><div class="blockquote"><table style="border:0" class="blockquote"><tr><td style="width:10%;vertical-align:top"> </td><td style="width:80%;vertical-align:top"><p>I understood Monads for exactly 5 minutes. Then the understanding left my head. It was too hard for me to keep there.</p></td><td style="width:10%;vertical-align:top"> </td></tr><tr><td style="width:10%;vertical-align:top"> </td><td style="text-align:right;vertical-align:top" colspan="2">--<span class="attribution"> An anonymous Perl 5 and <a class="link" href="https://en.wikipedia.org/wiki/Pugs_(programming)">Pugs</a> hacker about Haskell's Monads.</span></td></tr></table></div><p>As cool as Monads are I'm skeptical about using them in files by default. I know how to use File I/O in Haskell, but still don't understand when Monads are needed. My personal Haskell style so far made no use of them except for file Input and Output.</p><p>One will be able to implement Monads in Park and use them for file I/O. There may even be a default Monad class. However, the default file Input/Output API will either be a reflection of the POSIX one, or alternatively something similar in spirit to <a class="link" href="http://search.cpan.org/search?query=perlio&amp;mode=module">PerlIO</a> or the Python or Ruby files and sockets I/O classes.</p><p>Above this API one can build as many abstractions to his liking, including Monads.</p></section><section class="section"><div class="titlepage"><div><div><h5 id="bootstrapping_self_hosting_and_c_hosting" class="title">Bootstrapping, Self Hosting and C Hosting</h5></div></div></div><p>Bootstrapping is the process of implementing a virtual machine by implementing it using an existing virtual machine. So, for example perl 5, CPython, ruby, php and the Tcl interpreter are all written in C. That way they can be bootstrapped to run on any system for which a C compiler (such as <a class="link" href="http://gcc.gnu.org/">the Open-Source gcc</a> is available).</p><p>A related concept is Self-hosting, where a virtual machine's compiler or interpreter is written in itself. So for example, gcc is written in C and requires a C compiler to be built.</p><p>For C it is not really a problem, because one can use gcc or a different C compiler to cross-compile enough programs for it to run there conveniently. However,</p></section><section class="section"><div class="titlepage"><div><div><h5 id="constants_in_park" class="title">Constants in Park</h5></div></div></div><div class="blockquote"><table style="border:0" class="blockquote"><tr><td style="width:10%;vertical-align:top"> </td><td style="width:80%;vertical-align:top"><p>"I am not in Rome."</p></td><td style="width:10%;vertical-align:top"> </td></tr><tr><td style="width:10%;vertical-align:top"> </td><td style="text-align:right;vertical-align:top" colspan="2">--<span class="attribution"> An anonymous designer of his own DOS 8086 Assembly written in itself, and used to write other programs, in which numbers that start with 0 are hexadecimal.</span></td></tr></table></div><p>I encountered some Scheme implementations in which identifiers were case-sensitive, and some in which they were case-insensitive. To match what is the norm nowadays, and because I like it better, Park requires case-sensitive identifiers.</p><p>Numbers in Park can be decimal, octal (if they start with "0"), or hexadecimal (if they start with 0x). Following Perl's lead, one will be able to use underscores (<code class="literal">_</code>) within numbers (e.g: <code class="literal">100_000</code> instead of <code class="literal">100000</code>).</p><section class="section"><div class="titlepage"><div><div><h6 id="strings_quoting_and_interpolation" class="title">Strings, Quoting and Interpolation</h6></div></div></div><section class="section"><div class="titlepage"><div><div><h7 id="string_constants" class="title">String Constants</h7></div></div></div><p>String constants will be written in a large correspondence to the C, Perl 5 and Perl 6 conventions. For example, a "\n" will designate a newline. The exact type and quoting of the string will be determined by a few optional Perl 6-like modifiers. Here are a few examples:</p><pre class="programlisting">
# The (qq ... ) is not really needed but it doesn't hurt.
(my mystring (qq "Hello there, Hackers! Welcome to Park"))
(print mystring "\n")
(my regex (m :p5 "H..kers"))
(say (=~ mystring regex)) # Prints "Hackers"
(my conv (tr "H" "B"))
(say (=~ mystring conv)) # Prints "Bello there, Backers!..."
(my newstring mystring)
(=~! newstring conv)
# newstring is now "Bello there, Backers!..."
# (You gotta love S-expressions.)
</pre></section><section class="section"><div class="titlepage"><div><div><h7 id="string_interpolation" class="title">String Interpolation</h7></div></div></div><p>There was a very interesting presentation in an <a class="link" href="http://www.perl.org.il/">Israeli Perl Mongers meeting</a> about strings, quoting and interpolation in other languages and Perl. The presentation noted among else that in other languages one has to write relatively ugly code like <code class="literal">"Hello" &amp; Name &amp; "! What's up?"</code> rather than the Perl <code class="literal">"Hello $Name! What's up?"</code>.</p><p>In Perl 5 the interpreter has some heuristics for determining the end of the interpolated expression, which can be any arbitrary Perl expression. Perl 6 goes one step further and parses the string and translates it into Perl 6 code, so one can safely include arbitrarily complex code there. (In a similar fashion to the Korn shell "$(...)" construct).</p><p>What I plan is to have such interpolation in Park as well for some types of strings. The syntax will look something like that:</p><pre class="programlisting">
(my i 5 j 7)
(print "${i} + ${j} = $(+ i j)\n")
</pre><p>As expected this prints "5 + 7 = 12" (followed by a newline).</p><p>Another thing I'd like to have is shell or Perl 5-like here documents (<code class="literal">&amp;&amp;"EOF" ... EOF</code>)</p></section></section></section></section></section><div class="footnotes"><br/><hr class="footnote-hr"/><div id="ftn.about_the_slogan" class="footnote"><p><a href="#about_the_slogan" class="para"><sup class="para">[1] </sup></a>The "Park - Park is, is not, is too, is not Arc" slogan is temporary. The permanent slogan so far seems like it would be "Park - a LISP that starts with P".</p></div></div></section><footer/></body></html>